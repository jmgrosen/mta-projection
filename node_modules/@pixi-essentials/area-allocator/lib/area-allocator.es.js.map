{"version":3,"file":"area-allocator.es.js","sources":["../src/Area.ts","../src/GuilloteneAllocator.ts"],"sourcesContent":["/**\n * The orientation of an area indicates the axis along which it is split. This is a 1-bit field.\n * \n * @public\n */\nexport enum AreaOrientation {\n    HORIZONTAL = 0,\n    VERTICAL = 1\n};\n\n/**\n * Alias for the 31-bit field texture-area type.\n * \n * @public\n */\nexport type AreaField = number;\n\n/**\n * An area represents an oriented rectangular region. It is implemented as a 31-bit field. The open/close edges are\n * specified along its parent's orientation axis, i.e. if the parent is horizontal, the left and right edges are defined,\n * else if the parent is vertical, the top and bottom edges are defined. Similarly, the open/close edges of its\n * children will be along its own orientation axis.\n * \n * The orientation axes flip-flop along the hierarchy, i.e. an area's parent's orientation is always opposite to\n * the area's own orientation. This is because if the orientation were to be same, the area's children could be\n * \"pulled up\" to the parent making itself redundant.\n * \n * All four edges of an area can be retrieved from it and its parent.\n * \n * <table>\n *  <thead>\n *    <tr>\n *      <th>Field</th>\n *      <th>Bits</th>\n *      <th>Description</th>\n *    </tr>\n *  </thead>\n *  <tbody>\n *    <tr>\n *      <td>OPEN_OFFSET</td>\n *      <td>0-14</td>\n *      <td>\n *        The offset along the parent's axis at which the area begins. If orientation is horizontal,\n *        this is the left edge. If orientation is vertical, this is the top edge.\n *      </td>\n *    </tr>\n *    <tr>\n *      <td>CLOSE_OFFSET</td>\n *      <td>15-29</td>\n *      <td>\n *        The offset along the parent's axis at which the area ends. If orientation is horizontal,\n *        this is the right edge. If orientation is vertical, this is the bottom edge.\n *      </td>\n *    </tr>\n *    <tr>\n *      <td>ORIENTATION</td>\n *      <td>30</td>\n *      <td>\n *        The orientation of the area, which indicates the axis along it is split. The open and close\n *        offsets of its children are along this axis. See {@link AreaOrientation}.\n *      </td>\n *    </tr>\n *  </tbody>\n * </table>\n * \n * @public\n */\nexport class Area\n{\n    static makeArea(openOffset: number, closeOffset: number, orientation: number): number\n    {\n        return openOffset | (closeOffset << 15) | (orientation << 30);\n    }\n\n    static getOpenOffset(area: AreaField): number\n    {\n        return area & ((1 << 15) - 1);\n    }\n\n    static getCloseOffset(area: AreaField): number\n    {\n        return (area >> 15) & ((1 << 15) - 1);\n    }\n\n    static getOrientation(area: AreaField): AreaOrientation\n    {\n        return (area >> 30) & 1;\n    }\n\n    static setOpenOffset(area: AreaField, offset: number): number\n    {\n        return Area.makeArea(\n            offset,\n            Area.getCloseOffset(area),\n            Area.getOrientation(area)\n        );\n    }\n\n    static setCloseOffset(area: AreaField, offset: number): number\n    {\n        return Area.makeArea(\n            Area.getOpenOffset(offset),\n            offset,\n            Area.getOrientation(area)\n        );\n    }\n}","import { Rectangle } from '@pixi/math';\nimport { Area, AreaOrientation } from './Area';\n\nimport type { AreaAllocator } from './AreaAllocator';\nimport type { AreaField } from './Area';\n\n/**\n * An allocator node is represented as a tuple. The zeroth element is the parent of the node. The first element \n * always exists and is the texture area it wholly represents. The second element is whether the rectangle\n * is allocated or free. The last element is optional and is the list\n * of its children.\n *\n * @public\n * @ignore\n */\nexport type AreaNode = [AreaNode, AreaField, boolean] | [AreaNode, AreaField, AreaNode[]];\n\n/**\n * Pointer to guillotene node.\n * \n * @public\n * @ignore\n */\nexport type AreaPtr = { __mem_area: AreaNode };\n\n/**\n * @public\n * @ignore\n */\nexport enum SPLIT_ORIENTATION {\n    HOR = 0,\n    VERT = 1,\n    NONE = 2\n}\n\nconst tempRect = new Rectangle();\n\n/** @public */\nexport class GuilloteneAllocator implements AreaAllocator<AreaPtr>\n{\n    protected _root: AreaNode;\n\n    private _width: number;\n    private _height: number;\n\n    constructor(width: number, height: number)\n    {\n        this._width = width;\n        this._height = height;\n\n        // NOTE: getFrame assumes root node is always horizontal!\n        this._root = [\n            null,\n            Area.makeArea(0, this._height, AreaOrientation.HORIZONTAL),\n            false\n        ];\n    }\n\n    /**\n     * Allocates an area of the given `width` and `height`.\n     *\n     * @param width - The width required for the allocated area.\n     * @param height - The height required for the allocated area.\n     * @param rect - An optional `Rectangle` instance to put the resulting area frame into.\n     * @return The rectangle frame of the area allocated.\n     */\n    allocate(width: number, height: number, rect?: Rectangle): Rectangle & AreaPtr\n    {\n        const area = this.findArea(width, height);\n\n        if (!area)\n        {\n            return null;\n        }\n\n        if (!rect)\n        {\n            rect = new Rectangle();\n        }\n\n        this.getFrame(area, rect);\n\n        const hole = new Rectangle(rect.x, rect.y, width, height);\n        const node = this.split(area, rect, hole);\n\n        rect.copyFrom(hole);\n        (rect as any).__mem_area = node;\n\n        return rect as (Rectangle & AreaPtr);\n    }\n\n    /**\n     * Frees the area represented by the given area pointer. The original rectangle returned by\n     * {@link GuilloteneAllocator#allocate} included this pointer (the `__mem_area` property).\n     *\n     * @param areaPtr \n     */\n    free(areaPtr: AreaPtr): void\n    {\n        const area = areaPtr.__mem_area;\n\n        area[2] = false;\n        this.merge(area);\n    }\n\n    get width(): number\n    {\n        return this._width;\n    }\n\n    get height(): number\n    {\n        return this._height;\n    }\n\n    /**\n     * Returns the [area]{@link Area} data for the node.\n     *\n     * @param node \n     * @returns The area data for the node.\n     */\n    protected getAreaField(node: AreaNode): AreaField\n    {\n        return node[1];\n    }\n\n    /**\n     * Returns the rectangle covered by the area node.\n     *\n     * @param node - The node whose covered rectangular area is needed.\n     * @param rect - An optional `Rectangle` instance to put the data in.\n     * @return The rectangle covered by `node`.\n     */\n    protected getFrame(node: AreaNode, rect?: Rectangle): Rectangle\n    {\n        if (!rect)\n        {\n            rect = new Rectangle();\n        }\n\n        const nodeArea = this.getAreaField(node);\n        const nodeParent = this.getParent(node);\n        const nodeOrientation = Area.getOrientation(nodeArea);\n        const nodeOpen = Area.getOpenOffset(nodeArea);\n        const nodeClose = Area.getCloseOffset(nodeArea);\n        const parentOpen = nodeParent ? Area.getOpenOffset(nodeParent[1]) : 0;\n        const parentClose = nodeParent ? Area.getCloseOffset(nodeParent[1]) : this._width;// (because root node is horizontal)\n\n        if (nodeOrientation) // VERTICAL\n        {\n            rect.x = nodeOpen;\n            rect.y = parentOpen;\n            rect.width = nodeClose - rect.x;\n            rect.height = parentClose - parentOpen;\n        } \n        else // HORIZONTAL\n        {\n            rect.x = parentOpen;\n            rect.y = nodeOpen;\n            rect.width = parentClose - rect.x;\n            rect.height = nodeClose - rect.y;\n        }\n\n        return rect;\n    }\n\n    /**\n     * Returns the parent of the area node.\n     *\n     * @param node \n     * @return The parent of `node`\n     */\n    protected getParent(node: AreaNode): AreaNode\n    {\n        return node[0];\n    }\n\n    /**\n     * Returns whether the given node has any children.\n     *\n     * @param node \n     * @return Whether the given node has any children.\n     */\n    protected hasChildren(node: AreaNode): boolean\n    {\n        return (Array.isArray(node[2]) && (node[2].length !== 0));\n    }\n\n    /**\n     * Returns the children of the passed node, if any.\n     *\n     * @param node\n     */\n    protected getChildren(node: AreaNode): AreaNode[]\n    {\n        if (!Array.isArray(node[2])) {\n            throw new Error(\"Children don't exist\")\n        }\n\n        return node[2];\n    }\n\n    protected addChild(parent: AreaNode, ...nodes: AreaNode[]): void\n    {\n        parent[2] = Array.isArray(parent[2]) ? parent[2] : []\n        parent[2].push(...nodes)\n    }\n\n    /**\n     * Finds an area node with minimum width `aw` and minimum height `ah`.\n     *\n     * @param aw \n     * @param ah \n     */\n    protected findArea(aw: number, ah: number): AreaNode\n    {\n        return this.findAreaRecursive(this._root, aw, ah);\n    }\n\n    /**\n     * The recursive implementation for {@link AreaAllocator#findArea}.\n     *\n     * @param rootArea \n     * @param aw \n     * @param ah \n     */\n    protected findAreaRecursive(rootArea: AreaNode, aw: number, ah: number): AreaNode\n    {\n        const frame = this.getFrame(rootArea, tempRect);\n\n        if (frame.width < aw || frame.height < ah)\n        {\n            return null;\n        }\n\n        if (!this.hasChildren(rootArea))\n        {\n            const dx = frame.width - aw;\n            const dy = frame.height - ah;\n\n            if (dx < 0 || dy < 0 || rootArea[2])\n            {\n                return null;\n            }\n\n            return rootArea;\n        }\n\n        const children = this.getChildren(rootArea);\n\n        let bestCandidate = null;\n        let bestCandidateScore = Infinity;\n\n        for (let i = 0, j = children.length; i < j; i++)\n        {\n            const candidate = this.findAreaRecursive(children[i], aw, ah);\n\n            if (!candidate)\n            {\n                continue;\n            }\n\n            const candidateFrame = this.getFrame(candidate, tempRect);\n\n            const dx = candidateFrame.width - aw;\n            const dy = candidateFrame.height - ah;\n\n            if (dx < 0 || dy < 0)\n            {\n                continue;\n            }\n            if (!dx && !dy)\n            {\n                // Perfect fit!\n                return candidate;\n            }\n\n            const score = Math.min(dx, dy);\n\n            if (bestCandidateScore > score)\n            {\n                bestCandidate = candidate;\n                bestCandidateScore = score;\n            }\n        }\n\n        return bestCandidate;\n    }\n\n    /**\n     * Returns the orientation of the primary split of host.\n     */\n    protected splitOrientation(host: Rectangle, hole: Rectangle): SPLIT_ORIENTATION\n    {\n        if (hole.width === host.width && hole.height === host.height) {\n            return SPLIT_ORIENTATION.NONE;\n        }\n        if (hole.width === host.width) {\n            return SPLIT_ORIENTATION.VERT;\n        }\n        if (hole.height === host.height) {\n            return SPLIT_ORIENTATION.HOR;\n        }\n\n        // ____________________\n        // |        |         |\n        // |        |         |\n        // |  hole  |         |\n        // |        |         |\n        // |________| Primary |\n        // |        |         |\n        // |        |         |\n        // |  Sec.  |         |\n        // |________|_________|\n        const horAreaDiff = Math.abs(\n            // (Primary) Right\n            (host.width - hole.width) * host.height -\n            // (Secondary) Bottom\n            hole.width * (host.height - hole.height)\n        ) \n\n        // ____________________\n        // |        |         |\n        // |        |         |\n        // |  hole  | Sec.    |\n        // |        |         |\n        // |________|_________|\n        // |                  |\n        // |    Primary       |\n        // |__________________|\n        const verAreaDiff = Math.abs(\n            // (Primary) Bottom\n            host.width * (host.height - hole.height) -\n            (host.width - hole.width) * hole.height\n        )\n\n        if (horAreaDiff > verAreaDiff)\n        {\n            return SPLIT_ORIENTATION.HOR\n        } \n        else\n        {\n            return SPLIT_ORIENTATION.VERT\n        }\n    }\n\n    protected split(\n        area: AreaNode,\n        areaFrame: Rectangle,\n        holeFrame: Rectangle,\n        orientation: SPLIT_ORIENTATION = this.getParent(area) ? this.splitOrientation(areaFrame, holeFrame) : SPLIT_ORIENTATION.HOR\n    ): AreaNode\n    {\n        if (area[2] === true) \n        {\n            throw new Error('Cannot deallocate')\n        }\n        if (orientation === SPLIT_ORIENTATION.NONE)\n        {\n            area[2] = true;\n            return area;\n        }\n\n        return this[orientation === SPLIT_ORIENTATION.HOR \n            ? 'splitPrimaryHorizontal' \n            : 'splitPrimaryVertical'](area, areaFrame, holeFrame);\n    }\n\n    private splitPrimaryHorizontal(area: AreaNode, areaFrame: Rectangle, holeFrame: Rectangle): AreaNode\n    {\n        const field = this.getAreaField(area);\n        const axis = Area.getOrientation(field);\n        const parent = this.getParent(area);\n\n        if (this.hasChildren(area))\n        {\n            throw new Error(\"Can't split non-leaf node\")\n        }\n\n        const firstChild: AreaNode = [\n            area,\n            Area.makeArea(\n                areaFrame.left,\n                areaFrame.x + holeFrame.width,\n                AreaOrientation.VERTICAL\n            ),\n            []\n        ];\n        const secondChild: AreaNode = [\n            area,\n            Area.makeArea(\n                areaFrame.x + holeFrame.width, \n                areaFrame.right, \n                AreaOrientation.VERTICAL\n            ),\n            false\n        ];\n\n        if (axis === AreaOrientation.HORIZONTAL) {\n            this.addChild(area, firstChild, secondChild)\n        } else {\n            const i = this.getChildren(parent).indexOf(area);\n\n            firstChild[0] = parent;\n            secondChild[0] = parent;\n\n            this.getChildren(parent).splice(i, 1, firstChild, secondChild);\n        }\n\n        if (holeFrame.height !== areaFrame.height)\n        {\n            const secondaryFirstChild: AreaNode = [\n                firstChild,\n                Area.makeArea(\n                    areaFrame.top,\n                    areaFrame.y + holeFrame.height,\n                    AreaOrientation.HORIZONTAL\n                ),\n                true\n            ];\n            const secondarySecondChild: AreaNode = [\n                firstChild,\n                Area.makeArea(\n                    areaFrame.y + holeFrame.height,\n                    areaFrame.bottom,\n                    AreaOrientation.HORIZONTAL\n                ),\n                false\n            ];\n\n            this.addChild(firstChild, secondaryFirstChild, secondarySecondChild);\n\n            return secondaryFirstChild;\n        }\n        else\n        {\n            (firstChild as AreaNode)[2] = true;\n        }\n\n        return firstChild;\n    }\n\n    private splitPrimaryVertical(area: AreaNode, areaFrame: Rectangle, holeFrame: Rectangle): AreaNode\n    {\n        const field = this.getAreaField(area);\n        const axis = Area.getOrientation(field);\n        const parent = this.getParent(area);\n\n        if (this.hasChildren(area)) {\n            throw new Error(\"Can't split non-leaf node\")\n        }\n\n        const primaryFirstChild: AreaNode = [\n            area,\n            Area.makeArea(\n                areaFrame.top,\n                areaFrame.y + holeFrame.height,\n                AreaOrientation.HORIZONTAL\n            ),\n            []\n        ];\n        const primarySecondChild: AreaNode = [\n            area,\n            Area.makeArea(\n                areaFrame.y + holeFrame.height,\n                areaFrame.bottom,\n                AreaOrientation.HORIZONTAL\n            ),\n            false\n        ];\n\n        if (axis === AreaOrientation.VERTICAL) \n        {\n            this.addChild(area, primaryFirstChild, primarySecondChild);\n        }\n        else\n        {\n            const i = this.getChildren(parent).indexOf(area);\n            primaryFirstChild[0] = parent;\n            primarySecondChild[0] = parent;\n            this.getChildren(parent).splice(i, 1, primaryFirstChild, primarySecondChild);\n        }\n\n        if (holeFrame.width !== areaFrame.height)\n        {\n            const secondaryFirstChild: AreaNode = [\n                primaryFirstChild,\n                Area.makeArea(\n                    areaFrame.left,\n                    areaFrame.x + holeFrame.width,\n                    AreaOrientation.VERTICAL\n                ),\n                true\n            ];\n            const secondarySecondChild: AreaNode = [\n                primaryFirstChild,\n                Area.makeArea(\n                    areaFrame.x + holeFrame.width,\n                    areaFrame.right,\n                    AreaOrientation.VERTICAL\n                ),\n                false\n            ];\n\n            this.addChild(primaryFirstChild, secondaryFirstChild, secondarySecondChild);\n\n            return secondaryFirstChild;\n        }\n        else\n        {\n            (primaryFirstChild as AreaNode)[2] = true;\n        }\n\n        return primaryFirstChild;\n    }\n\n    protected merge(\n        area: AreaNode\n    ) {\n        if (this.hasChildren(area))\n        {\n            throw new Error(\"Cannot merge a non-leaf node\");\n        }\n\n        const parent = this.getParent(area);\n\n        if (!parent)\n        {\n            return;\n        }\n\n        const siblings = this.getChildren(parent);\n        const i = siblings.indexOf(area);\n\n        const leftSibling = siblings[i - 1];\n        const rightSibling = siblings[i + 1];\n\n        if (rightSibling && rightSibling[2] === false)\n        {\n            // Merge rightSibling into area\n            area[1] = Area.setCloseOffset(area[1], Area.getCloseOffset(rightSibling[1]));\n            siblings.splice(i + 1, 1);\n        }\n        if (leftSibling && leftSibling[2] === false)\n        {\n            // Merge leftSibling into area\n            area[1] = Area.setOpenOffset(area[1], Area.getOpenOffset(leftSibling[1]));\n            siblings.splice(i - 1, 1);\n        }\n\n        if (siblings.length === 1) {\n            parent[2] = false;\n            this.merge(parent);\n        }\n    }\n\n    private printState(area: AreaNode): void\n    {\n        if (!this.hasChildren(area)) {\n            console.log({ ...this.getFrame(area) }, area[2])\n        } else {\n            this.getChildren(area).forEach(n => this.printState(n))\n        }\n    }\n}"],"names":[],"mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8CACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;"}