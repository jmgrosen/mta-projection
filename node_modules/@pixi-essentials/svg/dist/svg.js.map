{"version":3,"file":"svg.js","sources":["../src/loader.ts","../src/paint/InheritedPaintProvider.ts","../src/paint/Paint.ts","../src/paint/PaintProvider.ts","../src/paint/PaintServer.ts","../src/utils/Path.ts","../src/utils/buildDashedLine.ts","../src/SVGGraphicsGeometry.ts","../src/style/DashedLineStyle.ts","../src/utils/EllipticArcUtils.ts","../src/SVGGraphicsNode.ts","../src/SVGImageNode.ts","../src/utils/buildPath.ts","../src/SVGPathNode.ts","../src/mask/L2RFilter.ts","../src/mask/MaskServer.ts","../src/const.ts","../src/SVGTextEngineImpl.ts","../src/utils/parseMeasurement.ts","../src/SVGTextNode.ts","../src/SVGUseNode.ts","../src/SVGScene.ts","../src/SVGSceneContext.ts","../src/SVGTextEngine.ts"],"sourcesContent":["/**\n * @internal\n * @ignore\n */\nconst _SVG_DOCUMENT_CACHE: Map<string, SVGSVGElement> = new Map();\n\n/**\n * @internal\n * @ignore \n */\nexport async function _load(href: string): Promise<SVGSVGElement> {\n    const url = new URL(href, document.baseURI);\n    const id = url.host + url.pathname;\n    let doc = _SVG_DOCUMENT_CACHE.get(id);\n\n    if (!doc)\n    {\n        doc = await fetch(url.toString())\n            .then((res) => res.text())\n            .then((text) => new DOMParser().parseFromString(text, 'image/svg+xml').documentElement as any);\n\n        _SVG_DOCUMENT_CACHE.set(id, doc);\n    }\n\n    return doc;\n}\n\n/**\n * Get information on the internal cache of the SVG loading mechanism.\n * \n * @public\n * @returns A view on the cache - clear() method and a size property.\n */\nexport function getLoaderCache(): {\n    clear(): void\n    size: number\n} {\n    return {\n        clear() {\n            _SVG_DOCUMENT_CACHE.clear();\n        },\n        size: _SVG_DOCUMENT_CACHE.size,\n    }\n}","import type { LINE_CAP, LINE_JOIN } from '@pixi/graphics';\nimport type { Paint } from './Paint';\n\n/**\n * Inherited paint, used for &lt;use /&gt; elements. The properties used on the inherited paint do not\n * override those on the parent.\n * \n * @public\n */\nexport class InheritedPaintProvider implements Paint\n{\n    public parent: Paint;\n    public provider: Paint;\n\n    /**\n     * Composes a `Paint` that will inherit properties from the `parent` if the `provider` does not\n     * define them.\n     *\n     * @param parent\n     * @param provider\n     */\n    constructor(parent: Paint, provider: Paint)\n    {\n        this.parent = parent;\n        this.provider = provider;\n    }\n\n    get dirtyId(): number\n    {\n        return this.parent.dirtyId + this.provider.dirtyId;\n    }\n\n    get fill(): number | string\n    {\n        return this.provider.fill !== null ? this.provider.fill : this.parent.fill;\n    }\n\n    get opacity(): number\n    {\n        return (typeof this.provider.opacity === 'number') ? this.provider.opacity : this.parent.opacity;\n    }\n\n    get stroke(): number | string\n    {\n        return this.provider.stroke !== null ? this.provider.stroke : this.parent.stroke;\n    }\n\n    get strokeDashArray(): number[]\n    {\n        return Array.isArray(this.provider.strokeDashArray) ? this.provider.strokeDashArray : this.parent.strokeDashArray;\n    }\n\n    get strokeDashOffset(): number\n    {\n        return typeof this.provider.strokeDashOffset === 'number'\n            ? this.provider.strokeDashOffset : this.parent.strokeDashOffset;\n    }\n\n    get strokeLineCap(): LINE_CAP\n    {\n        return typeof this.provider.strokeLineCap === 'string' ? this.provider.strokeLineCap : this.parent.strokeLineCap;\n    }\n\n    get strokeLineJoin(): LINE_JOIN\n    {\n        return typeof this.provider.strokeLineJoin === 'string' ? this.provider.strokeLineJoin : this.parent.strokeLineJoin;\n    }\n\n    get strokeMiterLimit(): number\n    {\n        return typeof this.provider.strokeMiterLimit === 'number'\n            ? this.provider.strokeMiterLimit : this.parent.strokeMiterLimit;\n    }\n\n    get strokeWidth(): number\n    {\n        return typeof this.provider.strokeWidth === 'number' ? this.provider.strokeWidth : this.parent.strokeWidth;\n    }\n}\n","import type { LINE_CAP, LINE_JOIN } from '@pixi/graphics';\n\n/**\n * Internal, parsed form of painting attributes. If a paint attribute was not defined, it **must** be\n * `null` (not `undefined`).\n *\n * @public\n * @see https://www.w3.org/TR/SVG2/painting.html#Introduction\n */\nexport interface Paint\n{\n    /**\n     * The interior paint for the shape.\n     */\n    readonly fill: number | string;\n\n    /**\n     * The opacity of the fill.\n     */\n    readonly opacity: number;\n\n    /**\n     * The color of the stroke outline applied on the shape.\n     */\n    readonly stroke: number | string;\n\n    /**\n     * The dash pattern for stroking the shape.\n     */\n    readonly strokeDashArray: number[];\n\n    /**\n     * The distance into the dash pattern at which the stroking is started.\n     */\n    readonly strokeDashOffset: number;\n\n    /**\n     * The line caps applied at the end of the stroke. This is not applied for closed shapes.\n     */\n    readonly strokeLineCap: LINE_CAP;\n\n    /**\n     * The line join applied at the joint to line segments.\n     */\n    readonly strokeLineJoin: LINE_JOIN;\n\n    /**\n     * The maximum miter distance.\n     */\n    readonly strokeMiterLimit: number;\n\n    /**\n     * The width of the stroke outline applied on the shape.\n     */\n    readonly strokeWidth: number;\n\n    /**\n     * Flags when the paint is updated.\n     */\n    readonly dirtyId: number;\n}\n","import { LINE_CAP, LINE_JOIN } from '@pixi/graphics';\nimport color from 'tinycolor2';\n\nimport type { Paint } from './Paint';\n\n/**\n * Provides the `Paint` for an `SVGElement`. It will also respond to changes in the attributes of the element\n * (not implemented).\n * \n * @public\n */\nexport class PaintProvider implements Paint\n{\n    public element: SVGElement;\n\n    public fill: number | string;\n    public opacity: number;\n    public stroke: number | string;\n    public strokeDashArray: number[];\n    public strokeDashOffset: number;\n    public strokeLineCap: LINE_CAP;\n    public strokeLineJoin: LINE_JOIN;\n    public strokeMiterLimit: number;\n    public strokeWidth: number;\n\n    public dirtyId = 0;\n\n    /**\n     * @param element - The element whose paint is to be provided.\n     */\n    constructor(element: SVGElement)\n    {\n        this.element = element;\n\n        const fill = element.getAttribute('fill');\n        const opacity = element.getAttribute('opacity');\n        const stroke = element.getAttribute('stroke');\n        const strokeDashArray = element.getAttribute('stroke-dasharray');\n        const strokeDashOffset = element.getAttribute('stroke-dashoffset');\n        const strokeLineCap = element.getAttribute('stroke-linecap');\n        const strokeLineJoin = element.getAttribute('stroke-linejoin');\n        const strokeMiterLimit = element.getAttribute('stroke-miterlimit');\n        const strokeWidth = element.getAttribute('stroke-width');\n\n        /* eslint-disable-next-line no-nested-ternary */\n        this.fill = fill !== null ? (fill === 'none' ? 'none' : PaintProvider.parseColor(fill)) : null;\n        this.opacity = opacity && parseFloat(opacity);\n        this.stroke = stroke && PaintProvider.parseColor(element.getAttribute('stroke'));\n        this.strokeDashArray = strokeDashArray\n            && strokeDashArray\n                ?.split(/[, ]+/g)\n                .map((num) => parseFloat(num.trim()));\n        this.strokeDashOffset = strokeDashOffset && parseFloat(strokeDashOffset);\n        this.strokeLineCap = strokeLineCap as unknown as LINE_CAP;\n        this.strokeLineJoin = strokeLineJoin as unknown as LINE_JOIN;\n        this.strokeMiterLimit = strokeMiterLimit && parseFloat(strokeMiterLimit);\n        this.strokeWidth = strokeWidth && parseFloat(strokeWidth);\n    }\n\n    /**\n     * Parses the color attribute into an RGBA hexadecimal equivalent, if encoded. If the `colorString` is `none` or\n     * is a `url(#id)` reference, it is returned as is.\n     *\n     * @param colorString\n     * @see https://github.com/bigtimebuddy/pixi-svg/blob/89e4ab834fa4ef05b64741596516c732eae34daa/src/SVG.js#L106\n     */\n    public static parseColor(colorString: string): number | string\n    {\n        /* Modifications have been made. */\n        /* Copyright (C) Matt Karl. */\n\n        if (!colorString)\n        {\n            return 0;\n        }\n        if (colorString === 'none' || colorString.startsWith('url'))\n        {\n            return colorString;\n        }\n\n        if (colorString[0] === '#')\n        {\n            // Remove the hash\n            colorString = colorString.substr(1);\n\n            // Convert shortcolors fc9 to ffcc99\n            if (colorString.length === 3)\n            {\n                colorString = colorString.replace(/([a-f0-9])/ig, '$1$1');\n            }\n\n            return parseInt(colorString, 16);\n        }\n\n        const { r, g, b } = color(colorString).toRgb();\n\n        return (r << 16) + (g << 8) + b;\n    }\n}\n","import { GradientFactory } from '@pixi-essentials/gradients';\nimport { PaintProvider } from './PaintProvider';\n\nimport type { Renderer, RenderTexture } from '@pixi/core';\nimport type { ColorStop } from '@pixi-essentials/gradients';\nimport type { Rectangle } from '@pixi/math';\n\n/**\n * Converts the linear gradient's x1, x2, y1, y2 attributes into percentage units.\n *\n * @param linearGradient - The linear gradient element whose attributes are to be converted.\n */\nfunction convertLinearGradientAxis(linearGradient: SVGLinearGradientElement): void\n{\n    linearGradient.x1.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PERCENTAGE);\n    linearGradient.y1.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PERCENTAGE);\n    linearGradient.x2.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PERCENTAGE);\n    linearGradient.y2.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PERCENTAGE);\n}\n\n/**\n * [Paint Servers]{@link https://svgwg.org/svg-next/pservers.html} are implemented as textures. This class is a lazy\n * wrapper around paint textures, which can only be generated using the `renderer` drawing to the screen.\n * \n * @public\n */\nexport class PaintServer\n{\n    public paintServer: SVGGradientElement | SVGPatternElement;\n    public paintTexture: RenderTexture;\n    public paintContexts: { [id: number]: number };\n\n    public dirtyId: number;\n\n    /**\n     * Creates a `PaintServer` wrapper.\n     *\n     * @param paintServer\n     * @param paintTexture\n     */\n    constructor(paintServer: SVGGradientElement | SVGPatternElement, paintTexture: RenderTexture)\n    {\n        this.paintServer = paintServer;\n        this.paintTexture = paintTexture;\n        this.paintContexts = {};\n        this.dirtyId = 0;\n    }\n\n    /**\n     * Ensures the paint texture is updated for the renderer's WebGL context. This should be called before using the\n     * paint texture to render anything.\n     *\n     * @param renderer - The renderer that will use the paint texture.\n     */\n    public resolvePaint(renderer: Renderer): void\n    {\n        const contextDirtyId = this.paintContexts[renderer.CONTEXT_UID];\n        const dirtyId = this.dirtyId;\n\n        if (contextDirtyId === undefined || contextDirtyId < dirtyId)\n        {\n            this.updatePaint(renderer);\n            this.paintContexts[renderer.CONTEXT_UID] = dirtyId;\n        }\n    }\n\n    /**\n     * Calculates the optimal texture dimensions for the paint texture, given the bounding box of the\n     * object applying it. The paint texture is resized accordingly.\n     *\n     * If the paint texture is sized smaller than the bounding box, then it is expected that it will\n     * be scaled up to fit it.\n     *\n     * @param bbox - The bounding box of the object applying the paint texture.\n     */\n    public resolvePaintDimensions(bbox: Rectangle): void\n    {\n        const bwidth = Math.ceil(bbox.width);\n        const bheight = Math.ceil(bbox.height);\n        const baspectRatio = bwidth / bheight;\n\n        const paintServer = this.paintServer;\n        const paintTexture = this.paintTexture;\n\n        if (paintServer instanceof SVGLinearGradientElement)\n        {\n            convertLinearGradientAxis(paintServer);\n\n            const colorStops = paintServer.children;\n            const x1 = paintServer.x1.baseVal.valueInSpecifiedUnits;\n            const y1 = paintServer.y1.baseVal.valueInSpecifiedUnits;\n            const x2 = paintServer.x2.baseVal.valueInSpecifiedUnits;\n            const y2 = paintServer.y2.baseVal.valueInSpecifiedUnits;\n\n            const mainAxisAngle = Math.atan2(y2 - y1, x2 - x1);\n            const mainAxisLength = colorStops.length === 1 ? 2 : 64;\n            let width = Math.max(1, mainAxisLength * Math.cos(mainAxisAngle));\n            let height = Math.max(1, mainAxisLength * Math.sin(mainAxisAngle));\n\n            if (width < bwidth && height < bheight)\n            {\n                // If the gradient is not parallel to x- or y- axis, then ensure that the texture's aspect ratio\n                // matches that of the bounding box. This will ensure scaling is equal along both axes, and the\n                // angle is not skewed due to scaling.\n                if (Math.abs(mainAxisAngle) > 1e-2\n                    && Math.abs(mainAxisAngle) % (Math.PI / 2) > 1e-2)\n                {\n                    const aspectRatio = width / height;\n\n                    if (aspectRatio > baspectRatio)\n                    {\n                        height = width / baspectRatio;\n                    }\n                    else\n                    {\n                        width = baspectRatio * height;\n                    }\n                }\n\n                paintTexture.resize(width, height, true);\n\n                return;\n            }\n        }\n\n        paintTexture.resize(bwidth, bheight, true);\n    }\n\n    /**\n     * Renders the paint texture using the renderer immediately.\n     *\n     * @param renderer - The renderer to use for rendering to the paint texture.\n     */\n    public updatePaint(renderer: Renderer): void\n    {\n        if (this.paintServer instanceof SVGLinearGradientElement)\n        {\n            this.linearGradient(renderer);\n        }\n        else if (this.paintServer instanceof SVGRadialGradientElement)\n        {\n            this.radialGradient(renderer);\n        }\n    }\n\n    /**\n     * Renders `this.paintServer` as a `SVGLinearGradientElement`.\n     *\n     * @param renderer - The renderer being used to render the paint texture.\n     */\n    private linearGradient(renderer: Renderer): RenderTexture\n    {\n        const linearGradient = this.paintServer as SVGLinearGradientElement;\n        const paintTexture = this.paintTexture;\n\n        convertLinearGradientAxis(linearGradient);\n\n        return GradientFactory.createLinearGradient(\n            renderer,\n            paintTexture,\n            {\n                x0: linearGradient.x1.baseVal.valueInSpecifiedUnits * paintTexture.width / 100,\n                y0: linearGradient.y1.baseVal.valueInSpecifiedUnits * paintTexture.height / 100,\n                x1: linearGradient.x2.baseVal.valueInSpecifiedUnits * paintTexture.width / 100,\n                y1: linearGradient.y2.baseVal.valueInSpecifiedUnits * paintTexture.height / 100,\n                colorStops: this.createColorStops(linearGradient.children),\n            },\n        );\n    }\n\n    /**\n     * Renders `this.paintServer` as a `SVGRadialGradientElement`.\n     *\n     * @param renderer - The renderer being used to render the paint texture.\n     */\n    private radialGradient(renderer: Renderer): RenderTexture\n    {\n        const radialGradient = this.paintServer as SVGRadialGradientElement;\n        const paintTexture = this.paintTexture;\n\n        radialGradient.fx.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_NUMBER);\n        radialGradient.fy.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_NUMBER);\n        radialGradient.cx.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_NUMBER);\n        radialGradient.cy.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_NUMBER);\n\n        return GradientFactory.createRadialGradient(\n            renderer,\n            paintTexture,\n            {\n                x0: radialGradient.fx.baseVal.valueInSpecifiedUnits * paintTexture.width / 100,\n                y0: radialGradient.fy.baseVal.valueInSpecifiedUnits * paintTexture.height / 100,\n                r0: radialGradient.fr.baseVal.valueInSpecifiedUnits * paintTexture.width / 100,\n                x1: radialGradient.cx.baseVal.valueInSpecifiedUnits * paintTexture.width / 100,\n                y1: radialGradient.cy.baseVal.valueInSpecifiedUnits * paintTexture.height / 100,\n                r1: radialGradient.r.baseVal.valueInSpecifiedUnits * paintTexture.width / 100,\n                colorStops: this.createColorStops(radialGradient.children),\n            },\n        );\n    }\n\n    /**\n     * Extracts the color-stops from the children of a `SVGGradientElement`.\n     *\n     * @param stopElements - The children of a `SVGGradientElement`. You can get it via `element.children`.\n     * @return The color stops that can be fed into {@link GradientFactory}.\n     */\n    private createColorStops(stopElements: HTMLCollection): ColorStop[]\n    {\n        const colorStops: ColorStop[] = [];\n\n        for (let i = 0, j = stopElements.length; i < j; i++)\n        {\n            const stopElement: SVGStopElement = stopElements.item(i) as SVGStopElement;\n\n            colorStops.push({\n                offset: stopElement.offset.baseVal,\n                color: PaintProvider.parseColor(stopElement.getAttribute('stop-color')) as number,\n            });\n        }\n\n        return colorStops;\n    }\n}\n","import { Bounds } from '@pixi/display';\n\n/** @internal */\nexport const PATH = 100;\n\n/**\n * @ignore\n * @public\n */\nexport type Contour = Array<number>;\n\n/**\n * The fill rules supported by {@link Path}.\n * \n * @public\n */\nexport enum FILL_RULE {\n    NONZERO = 'nonzero',\n    EVENODD = 'evenodd',\n}\n\n/**\n * Shape extension for Graphics\n * \n * @public\n */\nexport class Path\n{\n    /**\n     * The list of contours of this path, where a contour is a list of points.\n     *\n     * @member {Array.Array.<number>>}\n     */\n    contours: Contour[];\n\n    /** The fill rule of this path. */\n    fillRule: FILL_RULE;\n\n    /** The type of shape. This is always equal to 100 for now. */\n    type: number;\n\n    /** Whether the calculated bounds are dirty. */\n    protected dirty: boolean;\n\n    /** The calculated bounds of this path. */\n    protected bounds: Bounds = new Bounds();\n\n    /**\n     * Initializes the path with zero contours and a non-zero fill rule.\n     */\n    constructor()\n    {\n        this.contours = [];\n        this.fillRule = FILL_RULE.NONZERO;\n        this.type = PATH;\n        this.dirty = true;\n    }\n\n    /**\n     * Gets the points of the last contour in this path. If there are no contours, one is created.\n     */\n    get points(): number[]\n    {\n        if (!this.contours.length)\n        {\n            this.contours.push([]);\n        }\n\n        return this.contours[this.contours.length - 1];\n    }\n\n    /**\n     * Calculates whether the point (x, y) is inside this path or not.\n     *\n     * @param x - The x-coordinate of the point.\n     * @param y - The y-coordinate of the point.\n     * @return Whether (x, y) is inside this path.\n     */\n    contains(x: number, y: number): boolean\n    {\n        if (this.dirty)\n        {\n            this.calculateBounds();\n            this.dirty = false;\n        }\n\n        const bounds = this.bounds;\n\n        if (x < bounds.minX || y < bounds.minY ||\n            x > bounds.maxX || y > bounds.maxY)\n        {\n            return false;\n        }\n\n        if (this.fillRule === FILL_RULE.EVENODD)\n        {\n            return this.hitEvenOdd(x, y);\n        }\n        else if (this.fillRule === FILL_RULE.NONZERO)\n        {\n            return this.hitNonZero(x, y);\n        }\n\n        return false;\n    }\n\n    /**\n     * Clone this path.\n     */\n    clone(): Path\n    {\n        const contours = this.contours.map((c) => [...c]);\n        const path = new Path();\n\n        path.contours = contours;\n        path.fillRule = this.fillRule;\n\n        return path;\n    }\n\n    /**\n     * Closes the last contour of this path and pushes a new one.\n     */\n    closeContour(): void\n    {\n        if (this.points.length === 0)\n        {\n            return;\n        }\n\n        this.contours.push([]);\n    }\n\n    /**\n     * This should be called when the path is updated so that the hit-testing bounds are recalculated.\n     */\n    invalidate(): void\n    {\n        this.dirty = true;\n    }\n\n    toString(): string\n    {\n        return `[@pixi-essentials/svg:Path Don't expect points to be printed :P]`;\n    }\n\n    /**\n     * Recalculates the bounds of this path and sets {@link Path.bounds this.bounds}.\n     */\n    private calculateBounds()\n    {\n        const bounds = this.bounds\n\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n\n        for (const contour of this.contours)\n        {\n            for (let i = 0, j = contour.length; i < j;)\n            {\n                const x = contour[i++];\n                const y = contour[i++];\n\n                minX = x < minX ? x : minX;\n                minY = y < minY ? y : minY;\n                maxX = x > maxX ? x : maxX;\n                maxY = y > maxY ? y : maxY;\n            }\n        }\n\n        bounds.minX = minX;\n        bounds.minY = minY;\n        bounds.maxX = maxX;\n        bounds.maxY = maxY;\n    }\n    \n    /**\n     * Hit-tests the point (x, y) based on the even-odd fill rule.\n     * \n     * @see http://geomalgorithms.com/a03-_inclusion.html\n     */\n    private hitEvenOdd(x: number, y: number): boolean\n    {\n        // Here, we do we a ray tracing of a horizontally line extending from (x, y) infinitely towards the\n        // right. The number of edges crossing this ray are counted.\n        let crossingCount = 0;\n        \n        for (const contour of this.contours)\n        {\n            for (let i = 0, j = contour.length; i < j;)\n            {\n                const x0 = contour[i++];\n                const y0 = contour[i++];\n                const x1 = contour[i % contour.length];\n                const y1 = contour[(i + 1) % contour.length];\n\n                if ((y0 < y && y1 > y) ||  // Downward crossing\n                    (y0 > y && y1 < y))    // Upward crossing\n                {\n                    // Calculate the x-coordinate of the point of intersection.\n                    const it = (y - y0) / (y1 - y0);\n                    const ix = x0 + it * (x1  - x0);\n\n                    if (x < ix)\n                    {\n                        ++crossingCount;\n                    }\n                }\n            }\n        }\n\n        return !!(crossingCount % 2);\n    }\n\n    /**\n     * Hit-tests the point (x, y) based on non-zero fill rule.\n     *\n     * @see http://geomalgorithms.com/a03-_inclusion.html\n     */\n    private hitNonZero(x: number, y: number)\n    {\n        // Calculate the winding number of (x, y) by finding the net number of edges that cross the horizontal ray\n        // from (x, y) upwards minus downwards.\n        let windingNumber = 0;\n\n        for (const contour of this.contours)\n        {\n            for (let i = 0, j = contour.length; i < j;)\n            {\n                const x0 = contour[i++];\n                const y0 = contour[i++];\n                const x1 = contour[i % contour.length];\n                const y1 = contour[(i + 1) % contour.length];\n\n                if (y0 <= y)\n                {\n                    if (y1 > y &&   // Cross downward\n                        calculateSide(\n                            x, y,\n                            x0, y0,\n                            x1, y1\n                        ) > 0)      // (x, y) left of edge\n                    {\n                        ++windingNumber;\n                    }\n                }\n                else if (y1 <= y)    // Cross upward\n                {\n                    if (calculateSide(\n                        x, y,\n                        x0, y0,\n                        x1, y1\n                    ) < 0)           // (x, y) right of edge\n                    {\n                        --windingNumber;\n                    }                   \n                }\n            }\n        }\n\n        // Winding number will be zero for points outside the shape.\n        return windingNumber !== 0;\n    }\n}\n\n/**\n * Calculates whether (x, y) is left, on, or right of the line extending through (x0, y0) and (x1, y1).\n *\n * @ignore\n * @return > 0 if on on left side, = 0 if on line, < 0 if on right side\n */\nfunction calculateSide(x: number, y: number, x0: number, y0: number, x1: number, y1: number)\n{\n    // Basically calculate the area of the triangle (x0, y0), (x1, y1), (x, y), with vertices\n    // in that order. If counterlockwise, then the area is positive - then (x, y) is on left;\n\n    return (x1 - x0) * (y - y0) -  (x - x0) * (y1 - y0);\n}","import { GRAPHICS_CURVES, LINE_CAP, LINE_JOIN } from '@pixi/graphics';\nimport { Point, SHAPES } from '@pixi/math';\n\n// @ts-expect-error We'll export Polygon later.\nimport type { GraphicsData, GraphicsGeometry, LineStyle, Polygon } from '@pixi/graphics';\n\nfunction distanceTo(p0: Point, p1: Point): number\n{\n    return Math.sqrt(((p0.x - p1.x) ** 2) + ((p0.y - p1.y) ** 2)); \n}\n\n/**\n * Buffers vertices to draw a square cap.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} x - X-coord of end point\n * @param {number} y - Y-coord of end point\n * @param {number} nx - X-coord of line normal pointing inside\n * @param {number} ny - Y-coord of line normal pointing inside\n * @param {Array<number>} verts - vertex buffer\n * @returns {}\n */\nfunction square(\n    x: number,\n    y: number,\n    nx: number,\n    ny: number,\n    innerWeight: number,\n    outerWeight: number,\n    clockwise: boolean, /* rotation for square (true at left end, false at right end) */\n    verts: Array<number>,\n): number\n{\n    const ix = x - (nx * innerWeight);\n    const iy = y - (ny * innerWeight);\n    const ox = x + (nx * outerWeight);\n    const oy = y + (ny * outerWeight);\n\n    /* Rotate nx,ny for extension vector */\n    let exx; let\n        eyy;\n\n    if (clockwise)\n    {\n        exx = ny;\n        eyy = -nx;\n    }\n    else\n    {\n        exx = -ny;\n        eyy = nx;\n    }\n\n    /* [i|0]x,y extended at cap */\n    const eix = ix + exx;\n    const eiy = iy + eyy;\n    const eox = ox + exx;\n    const eoy = oy + eyy;\n\n    /* Square itself must be inserted clockwise*/\n    verts.push(eix, eiy);\n    verts.push(eox, eoy);\n\n    return 2;\n}\n\n/**\n * Buffers vertices to draw an arc at the line joint or cap.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n * @private\n * @param {number} cx - X-coord of center\n * @param {number} cy - Y-coord of center\n * @param {number} sx - X-coord of arc start\n * @param {number} sy - Y-coord of arc start\n * @param {number} ex - X-coord of arc end\n * @param {number} ey - Y-coord of arc end\n * @param {Array<number>} verts - buffer of vertices\n * @param {boolean} clockwise - orientation of vertices\n * @returns {number} - no. of vertices pushed\n */\nfunction round(\n    cx: number,\n    cy: number,\n    sx: number,\n    sy: number,\n    ex: number,\n    ey: number,\n    verts: Array<number>,\n    clockwise: boolean, /* if not cap, then clockwise is turn of joint, otherwise rotation from angle0 to angle1 */\n): number\n{\n    const cx2p0x = sx - cx;\n    const cy2p0y = sy - cy;\n\n    let angle0 = Math.atan2(cx2p0x, cy2p0y);\n    let angle1 = Math.atan2(ex - cx, ey - cy);\n\n    if (clockwise && angle0 < angle1)\n    {\n        angle0 += Math.PI * 2;\n    }\n    else if (!clockwise && angle0 > angle1)\n    {\n        angle1 += Math.PI * 2;\n    }\n\n    let startAngle = angle0;\n    const angleDiff = angle1 - angle0;\n    const absAngleDiff = Math.abs(angleDiff);\n\n    /* if (absAngleDiff >= PI_LBOUND && absAngleDiff <= PI_UBOUND)\n    {\n        const r1x = cx - nxtPx;\n        const r1y = cy - nxtPy;\n\n        if (r1x === 0)\n        {\n            if (r1y > 0)\n            {\n                angleDiff = -angleDiff;\n            }\n        }\n        else if (r1x >= -GRAPHICS_CURVES.epsilon)\n        {\n            angleDiff = -angleDiff;\n        }\n    }*/\n\n    const radius = Math.sqrt((cx2p0x * cx2p0x) + (cy2p0y * cy2p0y));\n    const segCount = ((15 * absAngleDiff * Math.sqrt(radius) / Math.PI) >> 0) + 1;\n    const angleInc = angleDiff / segCount;\n\n    startAngle += angleInc;\n\n    if (clockwise)\n    {\n        verts.push(cx, cy);\n        verts.push(sx, sy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx, cy);\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n        }\n\n        verts.push(cx, cy);\n        verts.push(ex, ey);\n    }\n    else\n    {\n        verts.push(sx, sy);\n        verts.push(cx, cy);\n\n        for (let i = 1, angle = startAngle; i < segCount; i++, angle += angleInc)\n        {\n            verts.push(cx + ((Math.sin(angle) * radius)),\n                cy + ((Math.cos(angle) * radius)));\n            verts.push(cx, cy);\n        }\n\n        verts.push(ex, ey);\n        verts.push(cx, cy);\n    }\n\n    return segCount * 2;\n}\n/**\n * Adapted from @pixi/graphics - buildNonNativeLine\n *\n * Builds a line to draw using the polygon method.\n *\n * Ignored from docs since it is not directly exposed.\n *\n * @ignore\n */\nfunction buildDash(points: number[], style: LineStyle, graphicsGeometry: GraphicsGeometry): void\n{\n    // get first and last point.. figure out the middle!\n\n    const verts = graphicsGeometry.points;\n    const length = points.length / 2;\n    let indexCount = points.length;\n    const indexStart = verts.length / 2;\n\n    // Max. inner and outer width\n    const width = style.width / 2;\n    const widthSquared = width * width;\n    const miterLimitSquared = style.miterLimit * style.miterLimit;\n\n    /* Line segments of interest where (x1,y1) forms the corner. */\n    let x0 = points[0];\n    let y0 = points[1];\n    let x1 = points[2];\n    let y1 = points[3];\n    let x2 = 0;\n    let y2 = 0;\n\n    /* perp[?](x|y) = the line normal with magnitude lineWidth. */\n    let perpx = -(y0 - y1);\n    let perpy = x0 - x1;\n    let perp1x = 0;\n    let perp1y = 0;\n\n    let dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    const ratio = style.alignment;// 0.5;\n    const innerWeight = (1 - ratio) * 2;\n    const outerWeight = ratio * 2;\n\n    // if (!closedShape)\n    // {\n    if (style.cap === LINE_CAP.ROUND)\n    {\n        indexCount += round(\n            x0 - (perpx * (innerWeight - outerWeight) * 0.5),\n            y0 - (perpy * (innerWeight - outerWeight) * 0.5),\n            x0 - (perpx * innerWeight),\n            y0 - (perpy * innerWeight),\n            x0 + (perpx * outerWeight),\n            y0 + (perpy * outerWeight),\n            verts,\n            true,\n        ) + 2;\n    }\n    else if (style.cap === LINE_CAP.SQUARE)\n    {\n        indexCount += square(x0, y0, perpx, perpy, innerWeight, outerWeight, true, verts);\n    }\n    // }\n\n    // Push first point (below & above vertices)\n    verts.push(\n        x0 - (perpx * innerWeight),\n        y0 - (perpy * innerWeight));\n    verts.push(\n        x0 + (perpx * outerWeight),\n        y0 + (perpy * outerWeight));\n\n    for (let i = 1; i < length - 1; ++i)\n    {\n        x0 = points[(i - 1) * 2];\n        y0 = points[((i - 1) * 2) + 1];\n\n        x1 = points[i * 2];\n        y1 = points[(i * 2) + 1];\n\n        x2 = points[(i + 1) * 2];\n        y2 = points[((i + 1) * 2) + 1];\n\n        perpx = -(y0 - y1);\n        perpy = x0 - x1;\n\n        dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n        perpx /= dist;\n        perpy /= dist;\n        perpx *= width;\n        perpy *= width;\n\n        perp1x = -(y1 - y2);\n        perp1y = x1 - x2;\n\n        dist = Math.sqrt((perp1x * perp1x) + (perp1y * perp1y));\n        perp1x /= dist;\n        perp1y /= dist;\n        perp1x *= width;\n        perp1y *= width;\n\n        /* d[x|y](0|1) = the component displacment between points p(0,1|1,2) */\n        const dx0 = x1 - x0;\n        const dy0 = y0 - y1;\n        const dx1 = x1 - x2;\n        const dy1 = y2 - y1;\n\n        /* +ve if internal angle counterclockwise, -ve if internal angle clockwise. */\n        const cross = (dy0 * dx1) - (dy1 * dx0);\n        const clockwise = (cross < 0);\n\n        /* Going nearly straight? */\n        if (Math.abs(cross) < 0.1)\n        {\n            verts.push(\n                x1 - (perpx * innerWeight),\n                y1 - (perpy * innerWeight));\n            verts.push(\n                x1 + (perpx * outerWeight),\n                y1 + (perpy * outerWeight));\n\n            continue;\n        }\n\n        /* p[x|y] is the miter point. pdist is the distance between miter point and p1. */\n        const c1 = ((-perpx + x0) * (-perpy + y1)) - ((-perpx + x1) * (-perpy + y0));\n        const c2 = ((-perp1x + x2) * (-perp1y + y1)) - ((-perp1x + x1) * (-perp1y + y2));\n        const px = ((dx0 * c2) - (dx1 * c1)) / cross;\n        const py = ((dy1 * c1) - (dy0 * c2)) / cross;\n        const pdist = ((px - x1) * (px - x1)) + ((py - y1) * (py - y1));\n\n        /* Inner miter point */\n        const imx = x1 + ((px - x1) * innerWeight);\n        const imy = y1 + ((py - y1) * innerWeight);\n        /* Outer miter point */\n        const omx = x1 - ((px - x1) * outerWeight);\n        const omy = y1 - ((py - y1) * outerWeight);\n\n        if (style.join === LINE_JOIN.BEVEL || pdist / widthSquared > miterLimitSquared)\n        {\n            if (clockwise) /* rotating at inner angle */\n            {\n                verts.push(imx, imy);// inner miter point\n                verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));// first segment's outer vertex\n                verts.push(imx, imy);// inner miter point\n                verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));// second segment's outer vertex\n            }\n            else /* rotating at outer angle */\n            {\n                verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight));// first segment's inner vertex\n                verts.push(omx, omy);// outer miter point\n                verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));// second segment's outer vertex\n                verts.push(omx, omy);// outer miter point\n            }\n\n            indexCount += 2;\n        }\n        else if (style.join === LINE_JOIN.ROUND)\n        {\n            if (clockwise) /* arc is outside */\n            {\n                verts.push(imx, imy);\n                verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n                indexCount += round(\n                    x1, y1,\n                    x1 + (perpx * outerWeight), y1 + (perpy * outerWeight),\n                    x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight),\n                    verts, true,\n                ) + 4;\n\n                verts.push(imx, imy);\n                verts.push(x1 + (perp1x * outerWeight), y1 + (perp1y * outerWeight));\n            }\n            else /* arc is inside */\n            {\n                verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight));\n                verts.push(omx, omy);\n\n                indexCount += round(\n                    x1, y1,\n                    x1 - (perpx * innerWeight), y1 - (perpy * innerWeight),\n                    x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight),\n                    verts, false\n                ) + 4;\n\n                verts.push(x1 - (perp1x * innerWeight), y1 - (perp1y * innerWeight));\n                verts.push(omx, omy);\n            }\n        }\n        else\n        {\n            verts.push(imx, imy);\n            verts.push(omx, omy);\n        }\n    }\n\n    x0 = points[(length - 2) * 2];\n    y0 = points[((length - 2) * 2) + 1];\n\n    x1 = points[(length - 1) * 2];\n    y1 = points[((length - 1) * 2) + 1];\n\n    perpx = -(y0 - y1);\n    perpy = x0 - x1;\n\n    dist = Math.sqrt((perpx * perpx) + (perpy * perpy));\n    perpx /= dist;\n    perpy /= dist;\n    perpx *= width;\n    perpy *= width;\n\n    verts.push(x1 - (perpx * innerWeight), y1 - (perpy * innerWeight));\n    verts.push(x1 + (perpx * outerWeight), y1 + (perpy * outerWeight));\n\n    // if (!closedShape)\n    // {\n    if (style.cap === LINE_CAP.ROUND)\n    {\n        indexCount += round(\n            x1 - (perpx * (innerWeight - outerWeight) * 0.5),\n            y1 - (perpy * (innerWeight - outerWeight) * 0.5),\n            x1 - (perpx * innerWeight),\n            y1 - (perpy * innerWeight),\n            x1 + (perpx * outerWeight),\n            y1 + (perpy * outerWeight),\n            verts,\n            false\n        ) + 2;\n    }\n    else if (style.cap === LINE_CAP.SQUARE)\n    {\n        indexCount += square(x1, y1, perpx, perpy, innerWeight, outerWeight, false, verts);\n    }\n    // }\n\n    const indices = graphicsGeometry.indices;\n    const eps2 = GRAPHICS_CURVES.epsilon * GRAPHICS_CURVES.epsilon;\n\n    // indices.push(indexStart);\n    for (let i = indexStart; i < indexCount + indexStart - 2; ++i)\n    {\n        x0 = verts[(i * 2)];\n        y0 = verts[(i * 2) + 1];\n\n        x1 = verts[(i + 1) * 2];\n        y1 = verts[((i + 1) * 2) + 1];\n\n        x2 = verts[(i + 2) * 2];\n        y2 = verts[((i + 2) * 2) + 1];\n\n        /* Skip zero area triangles */\n        if (Math.abs((x0 * (y1 - y2)) + (x1 * (y2 - y0)) + (x2 * (y0 - y1))) < eps2)\n        {\n            continue;\n        }\n\n        indices.push(i, i + 1, i + 2);\n    }\n}\n\nfunction inDash(i: number): boolean { return i % 2 === 0; }\nfunction incDash(i: number, dashArray: number[]): number { return (i + 1) % dashArray.length; }\n\nexport function buildDashedLine(graphicsData: GraphicsData, graphicsGeometry: GraphicsGeometry): void\n{\n    const shape = graphicsData.shape as Polygon;\n    let points = graphicsData.points || shape.points.slice();\n    const eps = graphicsGeometry.closePointEps;\n\n    if (points.length === 0)\n    {\n        return;\n    }\n\n    const firstPoint = new Point(points[0], points[1]);\n    const lastPoint = new Point(points[points.length - 2], points[points.length - 1]);\n\n    const closedShape = shape.type !== SHAPES.POLY || shape.closeStroke;\n    const closedPath = Math.abs(firstPoint.x - lastPoint.x) < eps\n        && Math.abs(firstPoint.y - lastPoint.y) < eps;\n\n    // if the first point is the last point - gonna have issues :)\n    if (closedShape)\n    {\n        // need to clone as we are going to slightly modify the shape..\n        points = points.slice();\n\n        if (closedPath)\n        {\n            points.pop();\n            points.pop();\n            lastPoint.set(points[points.length - 2], points[points.length - 1]);\n        }\n\n        const midPointX = (firstPoint.x + lastPoint.x) * 0.5;\n        const midPointY = (lastPoint.y + firstPoint.y) * 0.5;\n\n        points.unshift(midPointX, midPointY);\n        points.push(midPointX, midPointY);\n    }\n\n    const style = graphicsData.lineStyle;\n\n    // The length into the current dash that was already been added. This is needed for dashes\n    // that cover multiple line segments (e.g. path turns in middle of dash).\n    let dashOffset: number = (style as any).dashOffset || 0;\n\n    // Local copy of dash array\n    const dashArray: number[] = (style as any).dashArray || [10, 5];\n\n    // Number of line segments\n    const segCount = (points.length / 2) - 1;\n\n    // Start of each segment\n    const segStart = new Point();\n\n    // End of each segement\n    const segEnd = new Point();\n    \n    // Holds points for the dashes. When drawing a dash, this must contain more than one point. It\n    // may contain more than 2 points if the dash spans across multiple segments.\n    const segPoints = [];\n\n    // The current head of the dash algorithm\n    const dashPointer = new Point();\n\n    // The index in dashArray of location in the path at dashPointer\n    let dashArrayIndex = 0;\n\n    // Loop expects start of dash to already be present\n    segPoints.push(points[0], points[1]);\n\n    for (let i = 0; i < segCount; i++)\n    {\n        // Segment start point\n        segStart.set(points[i * 2], points[(i * 2) + 1]);\n\n        // Segment end point\n        segEnd.set(points[(i * 2) + 2], points[(i * 2) + 3]);\n\n        // Segment length\n        const segLength = distanceTo(segStart, segEnd);\n\n        const segAngle = Math.atan2(segEnd.y - segStart.y, segEnd.x - segStart.x);\n        const segSin = Math.sin(segAngle);\n        const segCos = Math.cos(segAngle);\n\n        let segSpace = segLength;\n\n        dashPointer.copyFrom(segStart);\n\n        while (segSpace >= (dashArray[dashArrayIndex] - dashOffset))\n        {\n            const dashLength = dashArray[dashArrayIndex] - dashOffset;\n\n            dashPointer.x += segCos * dashLength;\n            dashPointer.y += segSin * dashLength;\n            segPoints.push(dashPointer.x, dashPointer.y);\n\n            if (inDash(dashArrayIndex))\n            {\n                buildDash(segPoints, style, graphicsGeometry);\n                segPoints.length = 0;\n            }\n\n            segSpace -= dashLength;\n            dashArrayIndex = incDash(dashArrayIndex, dashArray);\n            dashOffset = 0;\n        }\n\n        if (segSpace > 0)\n        {\n            if (inDash(dashArrayIndex))\n            {\n                segPoints.push(segEnd.x, segEnd.y);\n            }\n\n            dashOffset += segSpace;\n        }\n    }\n\n    if (inDash(dashArrayIndex))\n    {\n        buildDash(segPoints, style, graphicsGeometry);\n    }\n}\n","import { Bounds } from '@pixi/display';\nimport { GraphicsGeometry } from '@pixi/graphics';\nimport { Matrix } from '@pixi/math';\nimport { PATH } from './utils/Path';\nimport { buildDashedLine } from './utils/buildDashedLine';\n\nimport type { GraphicsData } from '@pixi/graphics';\nimport type { DashedLineStyle } from './style/DashedLineStyle';\nimport type { Path } from './utils/Path';\nimport type { Circle, Ellipse, Polygon, Rectangle, RoundedRectangle } from '@pixi/math';\n\nconst tmpBounds = new Bounds();\n\n// @pixi/graphics should export this, ugh!\nenum SHAPES {\n    POLY = 0,\n    RECT = 1,\n    CIRC = 2,\n    ELIP = 3,\n    RREC = 4,\n}\n\n/** @public */\nexport class SVGGraphicsGeometry extends GraphicsGeometry\n{\n    processLine(data: GraphicsData): void\n    {\n        // @ts-expect-error Because we are extending the Shape enum.\n        if (data.shape.type === PATH)\n        {\n            this.processPathLine(data);\n\n            return;\n        }\n\n        const lineStyle = data.lineStyle as DashedLineStyle;\n\n        if (!lineStyle.dashArray)\n        {\n            super.processLine(data);\n        }\n        else\n        {\n            buildDashedLine(data, this);\n        }\n    }\n\n    processPathLine(data: GraphicsData): void\n    {\n        const path = data.shape as unknown as Path;\n        const lineStyle = data.lineStyle as DashedLineStyle;\n\n        path.contours.forEach((contour) =>\n        {\n            if (contour.find((e) => isNaN(e)) !== undefined)\n            {\n                console.error('Contour has NaN, oops!');\n\n                return;\n            }\n\n            if (lineStyle.dashArray)\n            {\n                buildDashedLine(\n                    {\n                        points: contour,\n                        holes: [],\n\n                        // @ts-expect-error\n                        shape: { points: contour, type: SHAPES.POLY },\n                        lineStyle,\n                    },\n                    this,\n                );\n            }\n            else\n            {\n                super.processLine({\n                    closeStroke: true,\n                    points: contour.slice(),\n                    holes: [],\n\n                    // @ts-expect-error\n                    shape: { points: contour, type: SHAPES.POLY },\n                    lineStyle,\n                });\n            }\n        });\n    }\n\n    protected calculateBounds(): void\n    {\n        const bounds = this._bounds;\n        const sequenceBounds = tmpBounds;\n        let curMatrix = Matrix.IDENTITY;\n\n        this._bounds.clear();\n        sequenceBounds.clear();\n\n        for (let i = 0; i < this.graphicsData.length; i++)\n        {\n            const data = this.graphicsData[i];\n            const shape = data.shape;\n            const type = data.type;\n            const lineStyle = data.lineStyle;\n            const nextMatrix = data.matrix || Matrix.IDENTITY;\n            let lineWidth = 0.0;\n\n            if (lineStyle && lineStyle.visible)\n            {\n                const alignment = lineStyle.alignment;\n\n                lineWidth = lineStyle.width;\n\n                if (type === SHAPES.POLY)\n                {\n                    lineWidth = lineWidth * (0.5 + Math.abs(0.5 - alignment));\n                }\n                else\n                {\n                    lineWidth = lineWidth * Math.max(0, alignment);\n                }\n            }\n\n            if (curMatrix !== nextMatrix)\n            {\n                if (!sequenceBounds.isEmpty())\n                {\n                    bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n                    sequenceBounds.clear();\n                }\n                curMatrix = nextMatrix;\n            }\n\n            if (type === SHAPES.RECT || type === SHAPES.RREC)\n            {\n                const rect = shape as Rectangle | RoundedRectangle;\n\n                sequenceBounds.addFramePad(rect.x, rect.y, rect.x + rect.width, rect.y + rect.height,\n                    lineWidth, lineWidth);\n            }\n            else if (type === SHAPES.CIRC)\n            {\n                const circle = shape as Circle;\n\n                sequenceBounds.addFramePad(circle.x, circle.y, circle.x, circle.y,\n                    circle.radius + lineWidth, circle.radius + lineWidth);\n            }\n            else if (type === SHAPES.ELIP)\n            {\n                const ellipse = shape as Ellipse;\n\n                sequenceBounds.addFramePad(ellipse.x, ellipse.y, ellipse.x, ellipse.y,\n                    ellipse.width + lineWidth, ellipse.height + lineWidth);\n            }\n            // @ts-expect-error Because we are extending the Shape enum.\n            else if (type === PATH)\n            {\n                const path = shape as any as Path;\n\n                path.contours.forEach((contour) =>\n                {\n                    bounds.addVerticesMatrix(Matrix.IDENTITY, new Float32Array(contour), 0, contour.length);\n                });\n            }\n            else\n            {\n                const poly = shape as Polygon;\n                // adding directly to the bounds\n\n                bounds.addVerticesMatrix(curMatrix, (poly.points as any), 0, poly.points.length, lineWidth, lineWidth);\n            }\n        }\n\n        if (!sequenceBounds.isEmpty())\n        {\n            bounds.addBoundsMatrix(sequenceBounds, curMatrix);\n        }\n\n        bounds.pad(this.boundsPadding, this.boundsPadding);\n    }\n}\n","import { LineStyle } from '@pixi/graphics';\n\nexport class DashedLineStyle extends LineStyle\n{\n    /**\n     * The dashing pattern of dashes and gaps to stroke paths.\n     */\n    public dashArray: number[] = null;\n\n    /**\n     * The distance into the dash pattern to start from.\n     */\n    public dashOffset = 0;\n\n    /**\n     * @override\n     */\n    public clone(): DashedLineStyle\n    {\n        const obj = super.clone() as DashedLineStyle;\n\n        obj.dashArray = this.dashArray ? [...this.dashArray] : null;\n        obj.dashOffset = this.dashOffset;\n\n        return obj;\n    }\n\n    /**\n     * @override\n     */\n    public reset(): void\n    {\n        super.reset();\n\n        this.dashArray = null;\n        this.dashOffset = 0;\n    }\n}\n","export const EllipticArcUtils = {\n    /**\n     * Approximates the arc length of an elliptical arc using numerical integration.\n     *\n     * @ignore\n     * @param rx - The radius along the x-axis.\n     * @param ry - The radius along the y-axis.\n     * @param startAngle - The starting eccentric angle, in radians.\n     * @param sweepAngle - The change in eccentric angle, in radians. This should be in the range (-2π, 2π).\n     * @param da - The size of angle intervals used in the Riemann sum.\n     * @see https://math.stackexchange.com/questions/433094/how-to-determine-the-arc-length-of-ellipse\n     */\n    calculateArcLength(rx: number, ry: number, startAngle: number, sweepAngle: number, da = 0.05): number\n    {\n        // We are integrating r(x) = √(a²sin²t + b²cos²t), which is used in the form √(a² + (b² - a²)cos²t)\n        // to reduce computations.\n\n        const sweepSign = Math.sign(sweepAngle);\n        const sweepAbsolute = Math.abs(sweepAngle);\n        const rx2 = rx * rx;\n        const ry2 = ry * ry;\n        const rdiff2 = ry2 - rx2;\n\n        let arcLength = 0;\n\n        // Samples are taken in the middle of each interval\n        for (let a = startAngle + (da * 0.5), delta = 0; delta < sweepAbsolute; a += sweepSign * da, delta += da)\n        {\n            const cos = Math.cos(a);\n            const cos2 = cos * cos;\n            const sample = Math.sqrt(rx2 + (rdiff2 * cos2));\n\n            arcLength += da * sample;\n        }\n\n        return arcLength;\n    },\n};\n","import { DashedLineStyle } from './style/DashedLineStyle';\nimport { EllipticArcUtils } from './utils/EllipticArcUtils';\nimport { Matrix } from '@pixi/math';\nimport { LINE_CAP, LINE_JOIN } from '@pixi/graphics';\nimport { GRAPHICS_CURVES, Graphics } from '@pixi/graphics';\nimport { SVGGraphicsGeometry } from './SVGGraphicsGeometry';\nimport { Texture } from '@pixi/core';\n\nimport type { PaintServer } from './paint/PaintServer';\nimport type { Renderer } from '@pixi/core';\nimport type { SVGSceneContext } from './SVGSceneContext';\n\n/**\n * @public\n * @ignore\n */\nexport interface ILineStyleOptions {\n    color?: number;\n    alpha?: number;\n    texture?: Texture;\n    matrix?: Matrix;\n\n    width?: number;\n    alignment?: number;\n    native?: boolean;\n    cap?: LINE_CAP;\n    join?: LINE_JOIN;\n    miterLimit?: number;\n\n    // additions\n    dashArray?: number[];\n    dashOffset?: number;\n}\n\nconst tempMatrix = new Matrix();\n\nconst _segmentsCount: (length: number, defaultSegments?: number) => number \n    = (GRAPHICS_CURVES as any)._segmentsCount.bind(GRAPHICS_CURVES);\n\n/**\n * This node can be used to directly embed the following elements:\n *\n * | Interface           | Element            |\n * | ------------------- | ------------------ |\n * | SVGGElement         | &lt;g /&gt;        |\n * | SVGCircleElement    | &lt;circle /&gt;   |\n * | SVGLineElement      | &lt;line /&gt;     |\n * | SVGPolylineElement  | &lt;polyline /&gt; |\n * | SVGPolygonElement   | &lt;polygon /&gt;  |\n * | SVGRectElement      | &lt;rect /&gt;     |\n *\n * It also provides an implementation for dashed stroking, by adding the `dashArray` and `dashOffset` properties\n * to `LineStyle`.\n * \n * @public\n */\nexport class SVGGraphicsNode extends Graphics\n{\n    paintServers: PaintServer[];\n\n    protected context: SVGSceneContext;\n\n    constructor(context: SVGSceneContext)\n    {\n        super();\n\n        this.context = context;\n\n        (this as any)._geometry = new SVGGraphicsGeometry();\n        (this as any)._geometry.refCount++;\n\n        this._lineStyle = new DashedLineStyle();\n\n        this.paintServers = [];\n    }\n\n    public lineTextureStyle(options: ILineStyleOptions): this\n    {\n        // Apply defaults\n        options = Object.assign({\n            width: 0,\n            texture: Texture.WHITE,\n            color: (options && options.texture) ? 0xFFFFFF : 0x0,\n            alpha: 1,\n            matrix: null,\n            alignment: 0.5,\n            native: false,\n            cap: LINE_CAP.BUTT,\n            join: LINE_JOIN.MITER,\n            miterLimit: 10,\n            dashArray: null,\n            dashOffset: 0,\n        }, options);\n\n        if (this.currentPath)\n        {\n            this.startPoly();\n        }\n\n        const visible = options.width > 0 && options.alpha > 0;\n\n        if (!visible)\n        {\n            this._lineStyle.reset();\n        }\n        else\n        {\n            if (options.matrix)\n            {\n                options.matrix = options.matrix.clone();\n                options.matrix.invert();\n            }\n\n            Object.assign(this._lineStyle, { visible }, options);\n        }\n\n        return this;\n    }\n\n    /**\n     * Draws an elliptical arc.\n     *\n     * @param cx - The x-coordinate of the center of the ellipse.\n     * @param cy - The y-coordinate of the center of the ellipse.\n     * @param rx - The radius along the x-axis.\n     * @param ry - The radius along the y-axis.\n     * @param startAngle - The starting eccentric angle, in radians (0 is at the 3 o'clock position of the arc's circle).\n     * @param endAngle - The ending eccentric angle, in radians.\n     * @param xAxisRotation - The angle of the whole ellipse w.r.t. x-axis.\n     * @param anticlockwise - Specifies whether the drawing should be counterclockwise or clockwise.\n     * @return This Graphics object. Good for chaining method calls.\n     */\n    ellipticArc(\n        cx: number,\n        cy: number,\n        rx: number,\n        ry: number,\n        startAngle: number,\n        endAngle: number,\n        xAxisRotation = 0,\n        anticlockwise = false): this\n    {\n        const sweepAngle = endAngle - startAngle;\n        const n = GRAPHICS_CURVES.adaptive\n            ? _segmentsCount(EllipticArcUtils.calculateArcLength(rx, ry, startAngle, endAngle - startAngle)) * 4\n            : 20;\n        const delta = (anticlockwise ? -1 : 1) * Math.abs(sweepAngle) / (n - 1);\n\n        tempMatrix.identity()\n            .translate(-cx, -cy)\n            .rotate(xAxisRotation)\n            .translate(cx, cy);\n\n        for (let i = 0; i < n; i++)\n        {\n            const eccentricAngle = startAngle + (i * delta);\n            const xr = cx + (rx * Math.cos(eccentricAngle));\n            const yr = cy + (ry * Math.sin(eccentricAngle));\n\n            const { x, y } = xAxisRotation !== 0 ? tempMatrix.apply({ x: xr, y: yr }) : { x: xr, y: yr };\n\n            if (i === 0)\n            {\n                this._initCurve(x, y);\n                continue;\n            }\n\n            this.currentPath.points.push(x, y);\n        }\n\n        return this;\n    }\n\n    /**\n     * Draws an elliptical arc to the specified point.\n     *\n     * If rx = 0 or ry = 0, then a line is drawn. If the radii provided are too small to draw the arc, then\n     * they are scaled up appropriately.\n     *\n     * @param endX - the x-coordinate of the ending point.\n     * @param endY - the y-coordinate of the ending point.\n     * @param rx - The radius along the x-axis.\n     * @param ry - The radius along the y-axis.\n     * @param xAxisRotation - The angle of the ellipse as a whole w.r.t/ x-axis.\n     * @param anticlockwise - Specifies whether the arc should be drawn counterclockwise or clockwise.\n     * @param largeArc - Specifies whether the larger arc of two possible should be choosen.\n     * @return This Graphics object. Good for chaining method calls.\n     * @see https://svgwg.org/svg2-draft/paths.html#PathDataEllipticalArcCommands\n     * @see https://www.w3.org/TR/SVG2/implnote.html#ArcImplementationNotes\n     */\n    ellipticArcTo(\n        endX: number,\n        endY: number,\n        rx: number,\n        ry: number,\n        xAxisRotation = 0,\n        anticlockwise = false,\n        largeArc = false,\n    ): this\n    {\n        if (rx === 0 || ry === 0)\n        {\n            return this.lineTo(endX, endY) as this;\n        }\n\n        // See https://www.w3.org/TR/SVG2/implnote.html#ArcImplementationNotes\n        const points = this.currentPath.points;\n        const startX = points[points.length - 2];\n        const startY = points[points.length - 1];\n        const midX = (startX + endX) / 2;\n        const midY = (startY + endY) / 2;\n\n        // Transform into a rotated frame with the origin at the midpoint.\n        const matrix = tempMatrix\n            .identity()\n            .translate(-midX, -midY)\n            .rotate(-xAxisRotation);\n        const { x: xRotated, y: yRotated } = matrix.apply({ x: startX, y: startY });\n\n        const a = Math.pow(xRotated / rx, 2) + Math.pow(yRotated / ry, 2);\n\n        if (a > 1)\n        {\n            // Ensure radii are large enough to connect start to end point.\n            rx = Math.sqrt(a) * rx;\n            ry = Math.sqrt(a) * ry;\n        }\n\n        const rx2 = rx * rx;\n        const ry2 = ry * ry;\n\n        // Calculate the center of the ellipse in this rotated space.\n        // See implementation notes for the equations: https://svgwg.org/svg2-draft/implnote.html#ArcImplementationNotes\n        const sgn = (anticlockwise === largeArc) ? 1 : -1;\n        const coef = sgn * Math.sqrt(\n            // use Math.abs to prevent numerical imprecision from creating very small -ve\n            // values (which should be zero instead). Otherwise, NaNs are possible\n            Math.abs((rx2 * ry2) - (rx2 * yRotated * yRotated) - (ry2 * xRotated * xRotated))\n            / ((rx2 * yRotated * yRotated) + (ry2 * xRotated * xRotated)),\n        );\n        const cxRotated = coef * (rx * yRotated / ry);\n        const cyRotated = -coef * (ry * xRotated / rx);\n\n        // Calculate the center of the ellipse back in local space.\n        const { x: cx, y: cy } = matrix.applyInverse({ x: cxRotated, y: cyRotated });\n\n        // Calculate startAngle\n        const x1Norm = (xRotated - cxRotated) / rx;\n        const y1Norm = (yRotated - cyRotated) / ry;\n        const dist1Norm = Math.sqrt((x1Norm ** 2) + (y1Norm ** 2));\n        const startAngle = (y1Norm >= 0 ? 1 : -1) * Math.acos(x1Norm / dist1Norm);\n\n        // Calculate endAngle\n        const x2Norm = (-xRotated - cxRotated) / rx;\n        const y2Norm = (-yRotated - cyRotated) / ry;\n        const dist2Norm = Math.sqrt((x2Norm ** 2) + (y2Norm ** 2));\n        let endAngle = (y2Norm >= 0 ? 1 : -1) * Math.acos(x2Norm / dist2Norm);\n\n        // Ensure endAngle is on the correct side of startAngle\n        if (endAngle > startAngle && anticlockwise)\n        {\n            endAngle -= Math.PI * 2;\n        }\n        else if (startAngle > endAngle && !anticlockwise)\n        {\n            endAngle += Math.PI * 2;\n        }\n\n        // Draw the ellipse!\n        this.ellipticArc(\n            cx, cy,\n            rx, ry,\n            startAngle,\n            endAngle,\n            xAxisRotation,\n            anticlockwise,\n        );\n\n        return this;\n    }\n\n    /**\n     * Embeds the `SVGCircleElement` into this node.\n     *\n     * @param element - The circle element to draw.\n     */\n    embedCircle(element: SVGCircleElement): void\n    {\n        element.cx.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n        element.cy.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n        element.r.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n\n        const cx = element.cx.baseVal.valueInSpecifiedUnits;\n        const cy = element.cy.baseVal.valueInSpecifiedUnits;\n        const r = element.r.baseVal.valueInSpecifiedUnits;\n\n        this.drawCircle(cx, cy, r);\n    }\n\n    /**\n     * Embeds the `SVGEllipseElement` into this node.\n     *\n     * @param element - The ellipse element to draw.\n     */\n    embedEllipse(element: SVGEllipseElement): void\n    {\n        element.cx.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n        element.cy.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n        element.rx.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n        element.ry.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n\n        const cx = element.cx.baseVal.valueInSpecifiedUnits;\n        const cy = element.cy.baseVal.valueInSpecifiedUnits;\n        const rx = element.rx.baseVal.valueInSpecifiedUnits;\n        const ry = element.ry.baseVal.valueInSpecifiedUnits;\n\n        this.ellipticArc(\n            cx,\n            cy,\n            rx,\n            ry,\n            0,\n            2 * Math.PI,\n        );\n    }\n\n    /**\n     * Embeds the `SVGLineElement` into this node.\n     *\n     * @param element - The line element to draw.\n     */\n    embedLine(element: SVGLineElement): void\n    {\n        element.x1.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n        element.y1.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n        element.x2.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n        element.y2.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n\n        const x1 = element.x1.baseVal.valueInSpecifiedUnits;\n        const y1 = element.y1.baseVal.valueInSpecifiedUnits;\n        const x2 = element.x2.baseVal.valueInSpecifiedUnits;\n        const y2 = element.y2.baseVal.valueInSpecifiedUnits;\n\n        this.moveTo(x1, y1);\n        this.lineTo(x2, y2);\n    }\n\n    /**\n     * Embeds the `SVGRectElement` into this node.\n     *\n     * @param element - The rectangle element to draw.\n     */\n    embedRect(element: SVGRectElement): void\n    {\n        element.x.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n        element.y.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n        element.width.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n        element.height.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n        element.rx.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n        element.ry.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n\n        const x = element.x.baseVal.valueInSpecifiedUnits;\n        const y = element.y.baseVal.valueInSpecifiedUnits;\n        const width = element.width.baseVal.valueInSpecifiedUnits;\n        const height = element.height.baseVal.valueInSpecifiedUnits;\n        const rx = element.rx.baseVal.valueInSpecifiedUnits;\n        const ry = element.ry.baseVal.valueInSpecifiedUnits || rx;\n\n        if (rx === 0 || ry === 0)\n        {\n            this.drawRect(x, y, width, height);\n        }\n        else\n        {\n            this.moveTo(x, y + ry);\n            this.ellipticArcTo(x + rx, y, rx, ry, 0, false, false);\n            this.lineTo(x + width - rx, y);\n            this.ellipticArcTo(x + width, y + ry, rx, ry, 0, false, false);\n            this.lineTo(x + width, y + height - ry);\n            this.ellipticArcTo(x + width - rx, y + height, rx, ry, 0, false, false);\n            this.lineTo(x + rx, y + height);\n            this.ellipticArcTo(x, y + height - ry, rx, ry, 0, false, false);\n            this.closePath();\n        }\n    }\n\n    /**\n     * Embeds the `SVGPolygonElement` element into this node.\n     *\n     * @param element - The polygon element to draw.\n     */\n    embedPolygon(element: SVGPolygonElement): void\n    {\n        const points = element.getAttribute('points')\n            .split(/[ ,]/g)\n            .map((p) => parseInt(p, 10));\n\n        this.moveTo(points[0], points[1]);\n\n        for (let i = 2; i < points.length; i += 2)\n        {\n            this.lineTo(points[i], points[i + 1]);\n        }\n\n        this.closePath();\n    }\n\n    /**\n     * Embeds the `SVGPolylineElement` element into this node.\n     *\n     * @param element - The polyline element to draw.\n     */\n    embedPolyline(element: SVGPolylineElement): void\n    {\n        const points = element.getAttribute('points')\n            .split(/[ ,]/g)\n            .map((p) => parseInt(p, 10));\n\n        this.moveTo(points[0], points[1]);\n\n        for (let i = 2; i < points.length; i += 2)\n        {\n            this.lineTo(points[i], points[i + 1]);\n        }\n    }\n\n    /**\n     * @override\n     */\n    render(renderer: Renderer): void\n    {\n        const paintServers = this.paintServers;\n\n        // Ensure paint servers are updated\n        for (let i = 0, j = paintServers.length; i < j; i++)\n        {\n            paintServers[i].resolvePaint(renderer);\n        }\n\n        super.render(renderer);\n    }\n}\n","import { BaseImageResource, Texture } from '@pixi/core';\nimport { Matrix } from '@pixi/math';\nimport { SVGGraphicsNode } from './SVGGraphicsNode';\n\nconst tempMatrix = new Matrix();\n\n/**\n * Draws SVG &lt;image /&gt; elements.\n * \n * @public\n */\nexport class SVGImageNode extends SVGGraphicsNode\n{\n    /**\n     * The canvas used into which the `SVGImageElement` is drawn. This is because WebGL does not support\n     * using `SVGImageElement` as an `ImageSource` for textures.\n     */\n    protected _canvas: HTMLCanvasElement;\n\n    /**\n     * The Canvas 2D context for `this._canvas`.\n     */\n    protected _context: CanvasRenderingContext2D;\n\n    /**\n     * A texture backed by `this._canvas`.\n     */\n    protected _texture: Texture;\n\n    /**\n     * Embeds the given SVG image element into this node.\n     *\n     * @param element - The SVG image element to embed.\n     */\n    embedImage(element: SVGImageElement): void\n    {\n        element.x.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n        element.y.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n        element.width.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n        element.height.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n\n        // Image frame\n        const x = element.x.baseVal.valueInSpecifiedUnits;\n        const y = element.y.baseVal.valueInSpecifiedUnits;\n        const width = element.width.baseVal.valueInSpecifiedUnits;\n        const height = element.height.baseVal.valueInSpecifiedUnits;\n        const opacity = Number.parseFloat(element.getAttribute('opacity') || '1');\n\n        // Calculate scale. If the <image /> element is scaled down, then the texture can be rendered at a lower\n        // resolution to save graphics memory.\n        const transform = element instanceof SVGGraphicsElement ? element.transform.baseVal.consolidate() : null;\n        const transformMatrix = transform ? transform.matrix : tempMatrix.identity();\n        const { a, b, c, d } = transformMatrix;\n        const sx = Math.min(1, Math.sqrt((a * a) + (b * b)));\n        const sy = Math.min(1, Math.sqrt((c * c) + (d * d)));\n        const twidth = Math.ceil(width * sx);\n        const theight = Math.ceil(height * sy);\n\n        // Initialize the texture & canvas\n        this.initTexture(twidth, theight);\n\n        // Load the image element\n        /* eslint-disable-next-line no-undef */\n        const baseURL = globalThis?.location.href;\n        const imageURL = element.getAttribute('href') || element.getAttribute('xlink:href');\n        const imageOrigin = new URL(imageURL).origin;\n        let imageElement: HTMLImageElement | SVGImageElement = element;\n\n        if (imageOrigin && imageOrigin !== baseURL)\n        {\n            imageElement = document.createElement('img');\n            imageElement.crossOrigin = 'anonymous';\n            imageElement.src = imageURL;\n        }\n\n        // Draw the image when it loads\n        imageElement.onload = (): void =>\n        {\n            this.drawTexture(imageElement);\n        };\n\n        // Generate the quad geometry\n        this.beginTextureFill({\n            texture: this._texture,\n            alpha: opacity,\n            matrix: new Matrix()\n                .scale(1 / sx, 1 / sy),\n        });\n        this.drawRect(x, y, width, height);\n        this.endFill();\n    }\n\n    /**\n     * Initializes {@code this._texture} by allocating it from the atlas. It is expected the texture size requested\n     * is less than the atlas's slab dimensions.\n     *\n     * @param width\n     * @param height\n     */\n    private initTexture(width: number, height: number): void\n    {\n        // If the texture already exists, nothing much to do.\n        if (this._texture)\n        {\n            if (this._texture.width <= this.context.atlas.maxWidth\n                && this._texture.height <= this.context.atlas.maxHeight)\n            {\n                this.context.atlas.free(this._texture);\n            }\n            else\n            {\n                // TODO: This does destroy it, right?\n                this._texture.destroy();\n            }\n        }\n\n        this._texture = null;\n        this._texture = this.context.atlas.allocate(width, height);\n\n        if (this._texture)\n        {\n            this._canvas = (this._texture.baseTexture.resource as BaseImageResource).source as HTMLCanvasElement;\n            this._context = this._canvas.getContext('2d');\n        }\n        else // Allocation fails if the texture is too large. If so, create a standalone texture.\n        {\n            this._canvas = document.createElement('canvas');\n\n            this._canvas.width = width;\n            this._canvas.height = height;\n\n            this._context = this._canvas.getContext('2d');\n            this._texture = Texture.from(this._canvas);\n        }\n    }\n\n    /**\n     * Draws the image into this node's texture.\n     *\n     * @param image - The image element holding the image.\n     */\n    private drawTexture(image: HTMLImageElement | SVGImageElement): void\n    {\n        const destinationFrame = this._texture.frame;\n\n        this._context.clearRect(\n            destinationFrame.x,\n            destinationFrame.y,\n            destinationFrame.width,\n            destinationFrame.height,\n        );\n\n        this._context.drawImage(\n            image,\n            destinationFrame.x,\n            destinationFrame.y,\n            destinationFrame.width,\n            destinationFrame.height,\n        );\n\n        this._texture.update();\n    }\n}\n","import { FILL_RULE } from './Path';\nimport * as libtess from 'libtess';\n\nimport type { GraphicsGeometry } from '@pixi/graphics';\nimport type { Path } from './Path';\n\n// Not used yet, tess2 isn't so good.\nexport const buildPath = {\n    build(): void\n    {\n        /* This method is intentionally blank. */\n    },\n    triangulate(graphicsData: any, graphicsGeometry: GraphicsGeometry): void\n    {\n        try\n        {\n            const path = graphicsData.shape as Path;\n            const contours = path.contours\n                .filter((c) => c.length > 0)\n                .filter((c) => (c.find((e) => isNaN(e)) === undefined));\n\n            const tessy = new libtess.GluTesselator();\n            const outVerts = [];\n\n            /* eslint-disable no-inner-declarations, @typescript-eslint/no-unused-vars */\n            function vertexCallback(data: number[], polyVertArray: number[]): void\n            {\n                // console.log(data[0], data[1]);\n                polyVertArray[polyVertArray.length] = data[0];\n                polyVertArray[polyVertArray.length] = data[1];\n            }\n            function begincallback(type: number): void\n            {\n                if (type !== libtess.primitiveType.GL_TRIANGLES) {\n                    console.warn(`expected TRIANGLES but got type: ${type}`);\n                }\n            }\n            function errorcallback(errno: number): void\n            {\n                console.error('error callback');\n                console.error(`error number: ${errno}`);\n            }\n            // callback for when segments intersect and must be split\n            function combinecallback(coords: number[], _data: any, _weight: any): number[]\n            {\n                // console.log('combine callback');\n                return [coords[0], coords[1], coords[2]];\n            }\n            function edgeCallback(_flag: number): void\n            {\n                // don't really care about the flag, but need no-strip/no-fan behavior\n                // console.log('edge flag: ' + flag);\n            }\n            /* eslint-enable no-inner-declarations */\n\n            tessy.gluTessProperty(libtess.gluEnum.GLU_TESS_WINDING_RULE,\n                path.fillRule === FILL_RULE.EVENODD\n                    ? libtess.windingRule.GLU_TESS_WINDING_ODD\n                    : libtess.windingRule.GLU_TESS_WINDING_NONZERO);\n            tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_VERTEX_DATA, vertexCallback);\n            tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_BEGIN, begincallback);\n            tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_ERROR, errorcallback);\n            tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_COMBINE, combinecallback);\n            tessy.gluTessCallback(libtess.gluEnum.GLU_TESS_EDGE_FLAG, edgeCallback);\n\n            tessy.gluTessNormal(0, 0, 1);\n            tessy.gluTessBeginPolygon(outVerts);\n\n            for (let i = 0; i < contours.length; i++)\n            {\n                const contour = contours[i];\n\n                tessy.gluTessBeginContour();\n\n                for (let j = 0; j < contour.length;)\n                {\n                    const x = contour[j++];\n                    const y = contour[j++];\n                    const data = [x, y, 0];\n\n                    tessy.gluTessVertex(data, data);\n                }\n\n                tessy.gluTessEndContour();\n            }\n\n            tessy.gluTessEndPolygon();\n\n            const verts = graphicsGeometry.points;\n            const indices = graphicsGeometry.indices;\n            const ibase = verts.length / 2;\n\n            for (let i = 0; i < outVerts.length;)\n            {\n                verts.push(outVerts[i++], outVerts[i++]);\n            }\n            for (let i = 0; i < outVerts.length / 2; i++)\n            {\n                indices.push(i + ibase);\n            }\n        }\n        catch (e)\n        {\n            console.error(e);\n        }\n    },\n};\n","import { FILL_RULE, Path, PATH } from './utils/Path';\nimport { SVGGraphicsNode } from './SVGGraphicsNode';\nimport { buildPath } from './utils/buildPath';\nimport { graphicsUtils } from '@pixi/graphics';\nimport dPathParser from 'd-path-parser';\n\ngraphicsUtils.FILL_COMMANDS[PATH] = buildPath;\n\n/**\n * Draws SVG &lt;path /&gt; elements.\n * \n * @public\n */\nexport class SVGPathNode extends SVGGraphicsNode\n{\n    private currentPath2: Path;\n\n    private startPath(): void\n    {\n        if (this.currentPath2)\n        {\n            const pts = this.currentPath2.points;\n\n            if (pts.length > 0)\n            {\n                this.currentPath2.closeContour();\n            }\n        }\n        else\n        {\n            this.currentPath2 = new Path();\n        }\n    }\n\n    private finishPath(): void\n    {\n        if (this.currentPath2)\n        {\n            this.currentPath2.closeContour();\n        }\n    }\n\n    // @ts-expect-error\n    get currentPath(): any\n    {\n        return this.currentPath2;\n    }\n    set currentPath(nothing: any)\n    {\n        if (nothing)\n        {\n            throw new Error('currentPath cannot be set');\n        }\n        // readonly\n    }\n\n    closePath(): any\n    {\n        this.currentPath2.points.push(this.currentPath2.points[0], this.currentPath2.points[1])\n        this.finishPath();\n\n        return this;\n    }\n\n    checkPath(): void\n    {\n        if (this.currentPath2.points.find((e) => isNaN(e)) !== undefined)\n        {\n            throw new Error('NaN is bad');\n        }\n    }\n\n    // Redirect moveTo, lineTo, ... onto paths!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! :P\n    startPoly = this.startPath;\n    finishPoly = this.finishPath;\n\n    /**\n     * Embeds the `SVGPathElement` into this node.\n     *\n     * @param element - the path to draw\n     */\n    embedPath(element: SVGPathElement): this\n    {\n        const d = element.getAttribute('d');\n\n        // Parse path commands using d-path-parser. This is an inefficient solution that causes excess memory allocation\n        // and should be optimized in the future.\n        const commands = dPathParser(d.trim());\n\n        // Current point\n        let x = 0;\n        let y = 0;\n\n        for (let i = 0, j = commands.length; i < j; i++)\n        {\n            const lastCommand = commands[i - 1];\n            const command = commands[i];\n\n            if (isNaN(x) || isNaN(y))\n            {\n                throw new Error('Data corruption');\n            }\n\n            // Taken from: https://github.com/bigtimebuddy/pixi-svg/blob/main/src/SVG.js\n            // Copyright Matt Karl\n            switch (command.code)\n            {\n                case 'm': {\n                    this.moveTo(\n                        x += command.end.x,\n                        y += command.end.y,\n                    );\n                    break;\n                }\n                case 'M': {\n                    this.moveTo(\n                        x = command.end.x,\n                        y = command.end.y,\n                    );\n                    break;\n                }\n                case 'H': {\n                    this.lineTo(x = command.value, y);\n                    break;\n                }\n                case 'h': {\n                    this.lineTo(x += command.value, y);\n                    break;\n                }\n                case 'V': {\n                    this.lineTo(x, y = command.value);\n                    break;\n                }\n                case 'v': {\n                    this.lineTo(x, y += command.value);\n                    break;\n                }\n                case 'z':\n                case 'Z': {\n                    x = this.currentPath2?.points[0] || 0;\n                    y = this.currentPath2?.points[1] || 0;\n                    this.closePath();\n                    break;\n                }\n                case 'L': {\n                    this.lineTo(\n                        x = command.end.x,\n                        y = command.end.y,\n                    );\n                    break;\n                }\n                case 'l': {\n                    this.lineTo(\n                        x += command.end.x,\n                        y += command.end.y,\n                    );\n                    break;\n                }\n                case 'C': {\n                    this.bezierCurveTo(\n                        command.cp1.x,\n                        command.cp1.y,\n                        command.cp2.x,\n                        command.cp2.y,\n                        x = command.end.x,\n                        y = command.end.y,\n                    );\n                    break;\n                }\n                case 'c': {\n                    const currX = x;\n                    const currY = y;\n\n                    this.bezierCurveTo(\n                        currX + command.cp1.x,\n                        currY + command.cp1.y,\n                        currX + command.cp2.x,\n                        currY + command.cp2.y,\n                        x += command.end.x,\n                        y += command.end.y,\n                    );\n                    break;\n                }\n                case 's':\n                case 'S': {\n                    const cp1 = { x, y };\n                    const lastCode = commands[i - 1] ? commands[i - 1].code : null;\n\n                    if (i > 0 && (lastCode === 's' || lastCode === 'S' || lastCode === 'c' || lastCode === 'C'))\n                    {\n                        const lastCommand = commands[i - 1];\n                        const lastCp2 = { ...(lastCommand.cp2 || lastCommand.cp) };\n\n                        if (commands[i - 1].relative)\n                        {\n                            lastCp2.x += (x - lastCommand.end.x);\n                            lastCp2.y += (y - lastCommand.end.y);\n                        }\n\n                        cp1.x = (2 * x) - lastCp2.x;\n                        cp1.y = (2 * y) - lastCp2.y;\n                    }\n\n                    const cp2 = { x: command.cp.x , y: command.cp.y };\n\n                    if (command.relative)\n                    {\n                        cp2.x += x;\n                        cp2.y += y;\n\n                        x += command.end.x;\n                        y += command.end.y;\n                    }\n                    else\n                    {\n                        x = command.end.x;\n                        y = command.end.y;\n                    }\n\n                    this.bezierCurveTo(\n                        cp1.x,\n                        cp1.y,\n                        cp2.x,\n                        cp2.y,\n                        x,\n                        y,\n                    );\n\n                    break;\n                }\n                case 'q': {\n                    const currX = x;\n                    const currY = y;\n\n                    this.quadraticCurveTo(\n                        currX + command.cp.x,\n                        currY + command.cp.y,\n                        x += command.end.x,\n                        y += command.end.y,\n                    );\n                    break;\n                }\n                case 'Q': {\n                    this.quadraticCurveTo(\n                        command.cp.x,\n                        command.cp.y,\n                        x = command.end.x,\n                        y = command.end.y,\n                    );\n                    break;\n                }\n                case 'A':\n                    this.ellipticArcTo(\n                        x = command.end.x,\n                        y = command.end.y,\n                        command.radii.x,\n                        command.radii.y,\n                        (command.rotation || 0) * Math.PI / 180,\n                        !command.clockwise,\n                        command.large,\n                    );\n                    break;\n                case 'a':\n                    this.ellipticArcTo(\n                        x += command.end.x,\n                        y += command.end.y,\n                        command.radii.x,\n                        command.radii.y,\n                        (command.rotation || 0) * Math.PI / 180,\n                        !command.clockwise,\n                        command.large,\n                    );\n\n                    break;\n                case 't':\n                case 'T': {\n                    let cx: number;\n                    let cy: number;\n\n                    if (lastCommand && lastCommand.cp)\n                    {\n                        let lcx = lastCommand.cp.x;\n                        let lcy = lastCommand.cp.y;\n\n                        if (lastCommand.relative)\n                        {\n                            const lx = x - lastCommand.end.x;\n                            const ly = y - lastCommand.end.y;\n\n                            lcx += lx;\n                            lcy += ly;\n                        }\n\n                        cx = (2 * x) - lcx;\n                        cy = (2 * y) - lcy;\n                    }\n                    else\n                    {\n                        cx = x;\n                        cy = y;\n                    }\n\n                    if (command.code === 't')\n                    {\n                        this.quadraticCurveTo(\n                            cx,\n                            cy,\n                            x += command.end.x,\n                            y += command.end.y,\n                        );\n                    }\n                    else\n                    {\n                        this.quadraticCurveTo(\n                            cx,\n                            cy,\n                            x = command.end.x,\n                            y = command.end.y,\n                        );\n                    }\n\n                    break;\n                }\n                default: {\n                    console.warn('[PIXI.SVG] Draw command not supported:', command.code, command);\n                    break;\n                }\n            }\n        }\n\n        if (this.currentPath2)\n        {\n            this.currentPath2.fillRule = element.getAttribute('fill-rule') as FILL_RULE || this.currentPath2.fillRule;\n            this.drawShape(this.currentPath2 as any);\n            this.currentPath2 = null;\n        }\n\n        return this;\n    }\n}\n","import { ColorMatrixFilter } from '@pixi/filter-color-matrix';\n\n/**\n * The luminance-to-red filter stores the luminance of the RGB components into the alpha channel\n * of the texture.\n *\n * @ignore\n */\nconst l2rFilter = new ColorMatrixFilter();\n\nl2rFilter.matrix = [\n    0.33, 0.33, 0.33, 0, 0,\n    0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0,\n    0.33, 0.33, 0.33, 0, 0,\n];\n\nexport { l2rFilter };\n","import { Rectangle } from '@pixi/math';\nimport { Sprite } from '@pixi/sprite';\nimport { l2rFilter } from './L2RFilter';\n\nimport type { Container, DisplayObject } from '@pixi/display';\nimport type { Renderer, RenderTexture } from '@pixi/core';\n\nconst tempSourceFrame = new Rectangle();\nconst tempDestinationFrame = new Rectangle();\n\n/**\n * A sprite that does not render anything. It can be used as a mask whose bounds can be updated by adding it\n * as a child of the mask-target.\n *\n * @public\n * @see MaskServer.createMask\n * @ignore\n */\nexport class MaskSprite extends Sprite\n{\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    render(_: Renderer): void\n    {\n        // NOTHING\n    }\n}\n\n/**\n * A `MaskServer` will lazily render its content's luminance into its render-texture's alpha\n * channel using the luminance-alpha filter. The `dirtyId` flag can be used to make it re-render its\n * contents. It is intended to be used as a sprite-mask, where black pixels are invisible and white\n * pixels are visible (i.e. black pixels are filtered to alpha = 0, while white pixels are filtered\n * to alpha = 1. The rest are filtered to an alpha such that 0 < alpha < 1.). This is in compliance\n * with [CSS Masking Module Level 1](https://www.w3.org/TR/css-masking-1/#MaskElement).\n *\n * @public\n * @ignore\n */\nexport class MaskServer extends Sprite\n{\n    /**\n     * Flags when re-renders are required due to content updates.\n     */\n    public dirtyId: number;\n\n    /**\n     * Flags when the content is re-rendered and should be equal to `this.dirtyId` when the texture\n     * is update-to-date.\n     */\n    public updateId: number;\n\n    /**\n     * @param texture - The render-texture that will cache the contents.\n     */\n    constructor(texture: RenderTexture)\n    {\n        super(texture);\n\n        this.dirtyId = 0;\n        this.updateId = -1;\n    }\n\n    /**\n     * @override\n     */\n    render(renderer: Renderer): void\n    {\n        if (this.dirtyId !== this.updateId)\n        {\n            // Update texture resolution, without changing screen-space resolution\n            this.texture.baseTexture.setSize(this.texture.width, this.texture.height, renderer.resolution);\n\n            renderer.batch.flush();\n\n            const renderTarget = renderer.renderTexture.current;\n            const sourceFrame = tempSourceFrame.copyFrom(renderer.renderTexture.sourceFrame);\n            const destinationFrame = tempDestinationFrame.copyFrom(renderer.renderTexture.destinationFrame);\n\n            const localBounds = (this as Sprite).getLocalBounds(null);\n            const children: DisplayObject[] = this.children;\n\n            renderer.renderTexture.bind(this.texture as RenderTexture, localBounds);\n            renderer.renderTexture.clear();\n            renderer.filter.push({ filterArea: localBounds, getBounds: () => localBounds }, [l2rFilter]);\n\n            for (let i = 0, j = children.length; i < j; i++)\n            {\n                const child = children[i];\n\n                child.enableTempParent();\n                child.updateTransform();\n                (children[i] as Container).render(renderer);\n                child.disableTempParent(this);\n            }\n\n            renderer.batch.flush();\n            renderer.filter.pop();\n\n            renderer.renderTexture.bind(renderTarget, sourceFrame, destinationFrame);\n\n            this.updateId = this.dirtyId;\n\n            this.getBounds();\n        }\n    }\n\n    /**\n     * Create a mask that will overlay on top of the given display-object using the texture of this\n     * mask server.\n     *\n     * @param displayObject - The mask target.\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    createMask(_: Container): MaskSprite\n    {\n        return new MaskSprite(this.texture);\n    }\n}\n","export const NODE_TRANSFORM_DIRTY: any = 'nodetransformdirty';\nexport const TRANSFORM_DIRTY: any = 'transformdirty';\n","import { NODE_TRANSFORM_DIRTY } from './const';\nimport { Sprite } from '@pixi/sprite';\nimport { Texture } from '@pixi/core';\nimport { TextMetrics, TextStyle } from '@pixi/text';\n\nimport type { IPointData, Matrix } from '@pixi/math';\nimport type { Renderer } from '@pixi/core';\nimport type { SVGTextEngine } from './SVGTextEngine';\n\n/**\n * `SVGTextEngineImpl` is the default implementation for {@link SVGTextEngine}. It is inspired by {@link PIXI.Text} that\n * is provided by @pixi/text. It uses a &lt;canvas /&gt; to draw and cache the text. This may cause blurring issues when\n * the SVG is viewed at highly zoomed-in scales because it is rasterized.\n *\n * @public\n */\nexport class SVGTextEngineImpl extends Sprite implements SVGTextEngine\n{\n    protected canvas: HTMLCanvasElement;\n    protected context: CanvasRenderingContext2D;\n    protected contentList: Map<any, {\n        position: IPointData;\n        content: string;\n        style: Partial<TextStyle>;\n        matrix?: Matrix;\n    }>;\n\n    protected dirtyId: number;\n    protected updateId: number;\n\n    constructor()\n    {\n        super(Texture.EMPTY);\n\n        this.canvas = document.createElement('canvas');\n        this.context = this.canvas.getContext('2d');\n        this.texture = Texture.from(this.canvas);\n\n        this.contentList = new Map();\n\n        this.dirtyId = 0;\n        this.updateId = 0;\n    }\n\n    async clear(): Promise<void>\n    {\n        this.contentList.clear();\n        this.dirtyId++;\n        this.position.set(0, 0);\n    }\n\n    async put(\n        id: any,\n        position: IPointData,\n        content: string,\n        style: Partial<TextStyle>,\n        matrix?: Matrix,\n    ): Promise<IPointData>\n    {\n        this.contentList.set(id, {\n            position,\n            content,\n            style,\n            matrix,\n        });\n\n        const textMetrics = TextMetrics.measureText(content, new TextStyle(style), false, this.canvas);\n\n        this.dirtyId++;\n\n        return {\n            x: position.x + textMetrics.width,\n            y: position.y,\n        };\n    }\n\n    updateText(): void\n    {\n        let w = 0;\n        let h = 0;\n\n        this.contentList.forEach(({ position, content, style }) =>\n        {\n            const textMetrics = TextMetrics.measureText(content, new TextStyle(style), false, this.canvas);\n\n            w = Math.max(w, position.x + textMetrics.width);\n            h = Math.max(h, position.y + textMetrics.height + textMetrics.fontProperties.descent);\n        });\n\n        const resolution = window.devicePixelRatio || 1;\n\n        this.canvas.width = w * resolution;\n        this.canvas.height = h * resolution;\n        this.texture.baseTexture.setRealSize(w, h, resolution);\n        this.texture.update();\n\n        this.context.clearRect(0, 0, w * resolution, h * resolution);\n        this.context.setTransform(1, 0, 0, 1, 0, 0);\n        this.context.scale(resolution, resolution);\n\n        let i = 0;\n\n        for (const [_, { position, content, style }] of this.contentList)\n        {\n            const textMetrics = TextMetrics.measureText(content, new TextStyle(style), false, this.canvas);\n            const textStyle = new TextStyle(style);\n\n            this.context.fillStyle = typeof textStyle.fill === 'string' ? textStyle.fill : 'black';\n            this.context.font = textStyle.toFontString();\n\n            this.context.fillText(content, position.x, position.y + textMetrics.height);\n\n            if (i === 0)\n            {\n                this.y -= textMetrics.height;\n            }\n\n            i++;\n        }\n\n        this.updateId = this.dirtyId;\n\n        // Ensure the SVG scene updates its bounds after the text is rendered.\n        this.emit(NODE_TRANSFORM_DIRTY);\n     }\n\n    render(renderer: Renderer): void\n    {\n        if (this.updateId !== this.dirtyId)\n        {\n            this.updateText();\n            this.updateTransform();\n        }\n\n        super.render(renderer);\n    }\n}\n","/**\n * Parses font measurements, e.g. '14px', '.5em'\n * @ignore\n */\nexport function parseMeasurement(mes: string, fontSize = 16): number\n{\n    if (!mes)\n    {\n        return 0;\n    }\n\n    // TODO: Handle non-px/em units\n\n    // Handle em\n    if (mes.includes('em'))\n    {\n        return parseFloat(mes) * fontSize;\n    }\n\n    return parseFloat(mes);\n}\n","import '@pixi/events';\nimport { Container } from '@pixi/display';\nimport { NODE_TRANSFORM_DIRTY } from './const';\nimport { SVGTextEngineImpl } from './SVGTextEngineImpl';\nimport { parseMeasurement } from './utils/parseMeasurement';\n\nimport type { DisplayObject } from '@pixi/display';\nimport type { IPointData } from '@pixi/math';\nimport type { SVGTextEngine } from './SVGTextEngine';\nimport type { TextStyle, TextStyleFontWeight } from '@pixi/text';\n\n/**\n * Draws SVG &lt;text /&gt; elements.\n *\n * @public\n */\nexport class SVGTextNode extends Container\n{\n    /**\n     * The SVG text rendering engine to be used by default in `SVGTextNode`. This API is not stable and\n     * can change anytime.\n     *\n     * @alpha\n     */\n    static defaultEngine: { new(): SVGTextEngine & DisplayObject } = SVGTextEngineImpl;\n\n    /**\n     * An instance of a SVG text engine used to layout and render text.\n     */\n    protected engine: SVGTextEngine & DisplayObject;\n\n    /**\n     * The current text position, where the next glyph will be placed.\n     */\n    protected currentTextPosition: IPointData;\n\n    constructor()\n    {\n        super();\n\n        this.currentTextPosition = { x: 0, y: 0 };\n        this.engine = new (SVGTextNode.defaultEngine)();\n        this.addChild(this.engine);\n\n        // Listen to nodetransformdirty on the engine so bounds are updated\n        // when the text is rendered.\n        this.engine.on(NODE_TRANSFORM_DIRTY, () => {\n            this.emit(NODE_TRANSFORM_DIRTY);\n        });\n    }\n\n    /**\n     * Embeds a `SVGTextElement` in this node.\n     *\n     * @param {SVGTextElement} element - The `SVGTextElement` to embed.\n     */\n    async embedText(element: SVGTextElement | SVGTSpanElement, style: Partial<TextStyle> = {}): Promise<void>\n    {\n        const engine = this.engine;\n\n        if (element instanceof SVGTextElement)\n        {\n            await engine.clear();\n\n            this.currentTextPosition.x = element.x.baseVal.length > 0\n                ? element.x.baseVal.getItem(0).value\n                : 0;\n            this.currentTextPosition.y = element.y.baseVal.length > 0\n                ? element.y.baseVal.getItem(0).value\n                : 0;\n        }\n\n        const fill = element.getAttribute('fill');\n        const fontFamily = element.getAttribute('font-family');\n        const fontSize = parseFloat(element.getAttribute('font-size'));\n        const fontWeight = element.getAttribute('font-weight');\n        const letterSpacing = parseMeasurement(element.getAttribute('letter-spacing'), fontSize);\n\n        style.fill = fill || style.fill || 'black';\n        style.fontFamily = fontFamily || !style.fontFamily ? `${fontFamily || 'serif'}, serif` : style.fontFamily;\n        style.fontSize = !isNaN(fontSize) ? fontSize : style.fontSize;\n        style.fontWeight = (fontWeight as TextStyleFontWeight) || style.fontWeight || 'normal';\n        style.letterSpacing = !isNaN(letterSpacing) ? letterSpacing : (style.letterSpacing || 0);\n        style.wordWrap = true;\n        style.wordWrapWidth = 400;\n\n        const childNodes = element.childNodes;\n\n        for (let i = 0, j = childNodes.length; i < j; i++)\n        {\n            const childNode = childNodes.item(i);\n\n            let textContent: string;\n            let textStyle: Partial<TextStyle>;\n\n            /* eslint-disable-next-line no-undef */\n            if (childNode instanceof globalThis.Text)\n            {\n                textContent = childNode.data;\n                textStyle = style;\n\n                this.currentTextPosition = await engine.put(\n                    childNode,\n                    {\n                        x: this.currentTextPosition.x,\n                        y: this.currentTextPosition.y,\n                    },\n                    textContent,\n                    textStyle,\n                );\n\n                // Ensure transforms are updated as new text phrases are loaded.\n                this.emit(NODE_TRANSFORM_DIRTY);\n            }\n            else if (childNode instanceof SVGTSpanElement)\n            {\n                if (childNode.x.baseVal.length > 0)\n                {\n                    this.currentTextPosition.x = childNode.x.baseVal.getItem(0).value;\n                }\n                if (childNode.y.baseVal.length > 0)\n                {\n                    this.currentTextPosition.y = childNode.y.baseVal.getItem(0).value;\n                }\n\n                await this.embedText(childNode, { ...style });\n            }\n        }\n    }\n}\n","import { Container } from '@pixi/display';\n\nimport type { SVGGraphicsNode } from './SVGGraphicsNode';\n\n/**\n * Container for rendering SVG &lt;use /&gt; elements.\n * \n * @public\n */\nexport class SVGUseNode extends Container\n{\n    public isRefExternal = false;\n\n    private _ref: SVGGraphicsNode;\n\n    /**\n     * Embeds the `SVGUseElement` into this node.\n     *\n     * @param element - The &lt;use /&gt; element to draw.\n     */\n    embedUse(element: SVGUseElement): void\n    {\n        element.x.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n        element.y.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n        element.width.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n        element.height.baseVal.convertToSpecifiedUnits(SVGLength.SVG_LENGTHTYPE_PX);\n\n        const x = element.x.baseVal.valueInSpecifiedUnits;\n        const y = element.y.baseVal.valueInSpecifiedUnits;\n\n        // TODO: width,height only have an efffect if the reference element is <svg> or <symbol>.\n        // const width = element.width.baseVal.valueInSpecifiedUnits;\n        // const height = element.height.baseVal.valueInSpecifiedUnits;\n\n        this.position.set(x, y);\n    }\n\n    /**\n     * The node that renders the element referenced by a &lt;element /&gt; element.\n     */\n    get ref(): SVGGraphicsNode\n    {\n        return this._ref;\n    }\n    set ref(value: SVGGraphicsNode)\n    {\n        if (this._ref)\n        {\n            if (this._ref === value)\n            {\n                return;\n            }\n\n            this.removeChild(this._ref);\n        }\n\n        this._ref = value;\n        this.addChild(this._ref);\n    }\n}","import { CanvasTextureAllocator } from '@pixi-essentials/texture-allocator';\nimport { Cull } from '@pixi-essentials/cull';\nimport { DisplayObject, Container } from '@pixi/display';\nimport { InheritedPaintProvider } from './paint/InheritedPaintProvider';\nimport { MaskServer } from './mask/MaskServer';\nimport { LINE_CAP, LINE_JOIN, GraphicsData } from '@pixi/graphics';\nimport * as Loader from './loader';\nimport { Matrix, Rectangle } from '@pixi/math';\nimport { NODE_TRANSFORM_DIRTY, TRANSFORM_DIRTY } from './const';\nimport { PaintProvider } from './paint/PaintProvider';\nimport { PaintServer } from './paint/PaintServer';\nimport { RenderTexture, Texture } from '@pixi/core';\nimport { SVGGraphicsNode } from './SVGGraphicsNode';\nimport { SVGImageNode } from './SVGImageNode';\nimport { SVGPathNode } from './SVGPathNode';\nimport { SVGTextNode } from './SVGTextNode';\nimport { SVGUseNode } from './SVGUseNode';\n\nimport type { Paint } from './paint/Paint';\nimport type { SVGSceneContext } from './SVGSceneContext';\nimport type { Renderer } from '@pixi/core';\n\nconst tempMatrix = new Matrix();\nconst tempRect = new Rectangle();\n\n/**\n * {@link SVGScene} can be used to build an interactive viewer for scalable vector graphics images. You must specify the size\n * of the svg viewer.\n *\n * ## SVG Scene Graph\n *\n * SVGScene has an internal, disconnected scene graph that is optimized for lazy updates. It will listen to the following\n * events fired by a node:\n *\n * * `nodetransformdirty`: This will invalidate the transform calculations.\n *\n * @public\n */\nexport class SVGScene extends DisplayObject\n{\n    /**\n     * The SVG image content being rendered by the scene.\n     */\n    public content: SVGSVGElement;\n\n    /**\n     * The root display object of the scene.\n     */\n    public root: Container;\n\n    /**\n     * Display objects that don't render to the screen, but are required to update before the rendering\n     * nodes, e.g. mask sprites.\n     */\n    public renderServers: Container;\n\n    /**\n     * The scene context\n     */\n    protected _context: SVGSceneContext;\n\n    /**\n     * The width of the rendered scene in local space.\n     */\n    protected _width: number;\n\n    /**\n     * The height of the rendered scene in local space.\n     */\n    protected _height: number;\n\n    /**\n     * This is used to cull the SVG scene graph before rendering.\n     */\n    protected _cull: Cull;\n\n    /**\n     * Maps content elements to their paint. These paints do not inherit from their parent element. You must\n     * compose an {@link InheritedPaintProvider} manually.\n     */\n    private _elementToPaint: Map<SVGElement, Paint>;\n\n    /**\n     * Maps `SVGMaskElement` elements to their nodes. These are not added to the scene graph directly and are\n     * only referenced as a `mask`.\n     */\n    private _elementToMask: Map<SVGElement, MaskServer>;\n\n    /**\n     * Flags whether any transform is dirty in the SVG scene graph.\n     */\n    protected _transformDirty: boolean;\n\n    sortDirty = false;\n\n    /**\n     * @param content - The SVG node to render\n     * @param context - This can be used to configure the scene\n     */\n    constructor(content: SVGSVGElement, context?: Partial<SVGSceneContext>)\n    {\n        super();\n\n        this.content = content;\n\n        this.initContext(context);\n        this._width = content.viewBox.baseVal.width;\n        this._height = content.viewBox.baseVal.height;\n\n        this._cull = new Cull({ recursive: true, toggle: 'renderable' });\n        this._elementToPaint = new Map();\n        this._elementToMask = new Map();\n        this._transformDirty = true;\n\n        this.renderServers = new Container();\n\n        if (!context || !context.disableRootPopulation)\n            this.populateScene();\n    }\n\n    initContext(context?: Partial<SVGSceneContext>): void\n    {\n        context = context || {};\n        context.atlas = context.atlas || new CanvasTextureAllocator(2048, 2048);\n        context.disableHrefSVGLoading = typeof context.disableHrefSVGLoading === 'undefined'\n            ? false : context.disableHrefSVGLoading;\n\n        this._context = context as SVGSceneContext;\n    }\n\n    /**\n     * Calculates the bounds of this scene, which is defined by the set `width` and `height`. The contents\n     * of this scene are scaled to fit these bounds, and don't affect them whatsoever.\n     *\n     * @override\n     */\n    calculateBounds(): void\n    {\n        this._bounds.clear();\n        this._bounds.addFrameMatrix(\n            this.worldTransform,\n            0,\n            0,\n            this.content.viewBox.baseVal.width,\n            this.content.viewBox.baseVal.height,\n        );\n    }\n\n    removeChild()\n    {\n        // Just to implement DisplayObject\n    }\n\n    /**\n     * @override\n     */\n    destroy(): void {\n        this.root.destroy(true);\n\n        super.destroy();\n    }\n\n    /**\n     * @override\n     */\n    render(renderer: Renderer): void\n    {\n        if (!this.visible || !this.renderable)\n        {\n            return;\n        }\n\n        // Update render-server objects\n        this.renderServers.render(renderer);\n\n        // Cull the SVG scene graph\n        this._cull.cull(renderer.renderTexture.sourceFrame, true);\n\n        // Render the SVG scene graph\n        this.root.render(renderer);\n\n        // Uncull the SVG scene graph. This ensures the scene graph is fully 'renderable'\n        // outside of a render cycle.\n        this._cull.uncull();\n    }\n\n    /**\n     * @override\n     */\n    updateTransform(): void\n    {\n        super.updateTransform();\n\n        this.root.alpha = this.worldAlpha;\n\n        const worldTransform = this.worldTransform;\n        const rootTransform = this.root.transform.worldTransform;\n\n        // Don't update transforms if they didn't change across frames. This is because the SVG scene graph is static.\n        if (rootTransform.a === worldTransform.a\n            && rootTransform.b === worldTransform.b\n            && rootTransform.c === worldTransform.c\n            && rootTransform.d === worldTransform.d\n            && rootTransform.tx === worldTransform.tx\n            && rootTransform.ty === worldTransform.ty\n            && (rootTransform as any)._worldID !== 0\n            && !this._transformDirty)\n        {\n            return;\n        }\n\n        this.root.enableTempParent();\n        this.root.transform.setFromMatrix(this.worldTransform);\n        this.root.updateTransform();\n        this.root.disableTempParent(null);\n\n        // Calculate bounds in the SVG scene graph. This ensures they are updated whenever the transform changes.\n        this.root.calculateBounds();\n\n        // Prevent redundant recalculations.\n        this._transformDirty = false;\n    }\n\n    /**\n     * Creates a display object that implements the corresponding `embed*` method for the given node.\n     *\n     * @param element - The element to be embedded in a display object.\n     */\n    protected createNode(element: SVGElement): Container\n    {\n        let renderNode = null;\n\n        switch (element.nodeName.toLowerCase())\n        {\n            case 'circle':\n            case 'ellipse':\n            case 'g':\n            case 'line':\n            case 'polyline':\n            case 'polygon':\n            case 'rect':\n                renderNode = new SVGGraphicsNode(this._context);\n                break;\n            case 'image':\n                renderNode = new SVGImageNode(this._context);\n                break;\n            case 'mask':\n            case 'svg':\n                renderNode = new Container();\n                break;\n            case 'path':\n                renderNode = new SVGPathNode(this._context);\n                break;\n            case 'text':\n                renderNode = new SVGTextNode();\n                break;\n            case 'use':\n                renderNode = new SVGUseNode();\n                break;\n            default:\n                renderNode = null;\n                break;\n        }\n\n        return renderNode;\n    }\n\n    /**\n     * Creates a `Paint` object for the given element. This should only be used when sharing the `Paint`\n     * is not desired; otherwise, use {@link SVGScene.queryPaint}.\n     *\n     * This will return `null` if the passed element is not an instance of `SVGElement`.\n     *\n     * @alpha\n     * @param element\n     */\n    protected createPaint(element: SVGElement): Paint\n    {\n        if (!(element instanceof SVGElement))\n        {\n            return null;\n        }\n\n        return new PaintProvider(element);\n    }\n\n    /**\n     * Creates a lazy paint texture for the paint server.\n     *\n     * @alpha\n     * @param paintServer - The paint server to be rendered.\n     */\n    protected createPaintServer(paintServer: SVGGradientElement): PaintServer\n    {\n        const renderTexture = RenderTexture.create({\n            width: 128,\n            height: 128,\n        });\n\n        return new PaintServer(paintServer, renderTexture);\n    }\n\n    /**\n     * Creates a lazy luminance mask for the `SVGMaskElement` or its rendering node.\n     *\n     * @param ref - The `SVGMaskElement` or its rendering node, if already generated.\n     */\n    protected createMask(ref: SVGMaskElement | Container): MaskServer\n    {\n        if (ref instanceof SVGElement)\n        {\n            ref = this.populateSceneRecursive(ref, {\n                basePaint: this.queryInheritedPaint(ref),\n            });\n        }\n\n        const localBounds = ref.getLocalBounds();\n\n        ref.getBounds();\n\n        const maskTexture = RenderTexture.create({\n            width: localBounds.width,\n            height: localBounds.height,\n        });\n\n        const maskSprite = new MaskServer(maskTexture);\n\n        // Lazily render mask when needed.\n        maskSprite.addChild(ref);\n\n        return maskSprite;\n    }\n\n    /**\n     * Returns the rendering node for a mask.\n     *\n     * @alpha\n     * @param ref - The mask element whose rendering node is needed.\n     */\n    protected queryMask(ref: SVGMaskElement): MaskServer\n    {\n        let queryHit = this._elementToMask.get(ref);\n\n        if (!queryHit)\n        {\n            queryHit = this.createMask(ref);\n\n            this._elementToMask.set(ref, queryHit);\n        }\n\n        return queryHit;\n    }\n\n    /**\n     * Returns the cached paint of a content element. The returned paint will not account for any paint\n     * attributes inherited from ancestor elements.\n     *\n     * @alpha\n     * @param ref - A reference to the content element.\n     */\n    protected queryPaint(ref: SVGElement): Paint\n    {\n        let queryHit = this._elementToPaint.get(ref);\n\n        if (!queryHit)\n        {\n            queryHit = this.createPaint(ref);\n            this._elementToPaint.set(ref, queryHit);\n        }\n\n        return queryHit;\n    }\n\n    /**\n     * Returns an (uncached) inherited paint of a content element.\n     *\n     * @alpha\n     * @param ref\n     */\n    protected queryInheritedPaint(ref: SVGElement): Paint\n    {\n        const paint = this.queryPaint(ref);\n        const parentPaint = ref.parentElement && this.queryPaint(ref.parentElement as unknown as SVGElement);\n\n        if (!parentPaint)\n        {\n            return paint;\n        }\n\n        return new InheritedPaintProvider(parentPaint, paint);\n    }\n\n    /**\n     * Parses the internal URL reference into a selector (that can be used to find the\n     * referenced element using `this.content.querySelector`).\n     *\n     * @param url - The reference string, e.g. \"url(#id)\", \"url('#id')\", \"#id\"\n     */\n    protected parseReference(url: string): string\n    {\n        if (url.startsWith('url'))\n        {\n            let contents = url.slice(4, -1);\n\n            if (contents.startsWith('\\'') && contents.endsWith('\\''))\n            {\n                contents = contents.slice(1, -1);\n            }\n\n            return contents;\n        }\n\n        return url;\n    }\n\n    /**\n     * Embeds a content `element` into the rendering `node`.\n     *\n     * This is **not** a stable API.\n     *\n     * @alpha\n     * @param node - The node in this scene that will render the `element`.\n     * @param element - The content `element` to be rendered. This must be an element of the SVG document\n     *  fragment under `this.content`.\n     * @param options - Additional options\n     * @param {Paint} [options.basePaint] - The base paint that the element's paint should inherit from\n     * @return The base attributes of the element, like paint.\n     */\n    protected embedIntoNode(\n        node: Container,\n        element: SVGGraphicsElement | SVGMaskElement,\n        options: {\n            basePaint?: Paint;\n        } = {},\n    ): {\n        paint: Paint;\n    }\n    {\n        const {\n            basePaint,\n        } = options;\n\n        // Paint\n        const paint = basePaint ? new InheritedPaintProvider(basePaint, this.queryPaint(element)) : this.queryPaint(element);\n        const {\n            fill,\n            opacity,\n            stroke,\n            strokeDashArray,\n            strokeDashOffset,\n            strokeLineCap,\n            strokeLineJoin,\n            strokeMiterLimit,\n            strokeWidth,\n        } = paint;\n\n        // Transform\n        const transform = element instanceof SVGGraphicsElement ? element.transform.baseVal.consolidate() : null;\n        const transformMatrix = transform ? transform.matrix : tempMatrix.identity();\n\n        if (node instanceof SVGGraphicsNode)\n        {\n            if (fill === 'none')\n            {\n                node.beginFill(0, 0);\n            }\n            else if (typeof fill === 'number')\n            {\n                node.beginFill(fill, opacity === null ? 1 : opacity);\n            }\n            else if (!fill)\n            {\n                node.beginFill(0);\n            }\n            else\n            {\n                const ref = this.parseReference(fill);\n                const paintElement = this.content.querySelector(ref);\n\n                if (paintElement && paintElement instanceof SVGGradientElement)\n                {\n                    const paintServer = this.createPaintServer(paintElement);\n                    const paintTexture = paintServer.paintTexture;\n\n                    node.paintServers.push(paintServer);\n                    node.beginTextureFill({\n                        texture: paintTexture,\n                        alpha: opacity === null ? 1 : opacity,\n                        matrix: new Matrix(),\n                    });\n                }\n            }\n\n            let strokeTexture: Texture;\n\n            if (typeof stroke === 'string' && stroke.startsWith('url'))\n            {\n                const ref = this.parseReference(stroke);\n                const paintElement = this.content.querySelector(ref);\n\n                if (paintElement && paintElement instanceof SVGGradientElement)\n                {\n                    const paintServer = this.createPaintServer(paintElement);\n                    const paintTexture = paintServer.paintTexture;\n\n                    node.paintServers.push(paintServer);\n                    strokeTexture = paintTexture;\n                }\n            }\n\n            node.lineTextureStyle({\n                /* eslint-disable no-nested-ternary */\n                color: stroke === null ? 0 : (typeof stroke === 'number' ? stroke : 0xffffff),\n                cap: strokeLineCap === null ? LINE_CAP.SQUARE : strokeLineCap as unknown as LINE_CAP,\n                dashArray: strokeDashArray,\n                dashOffset: strokeDashOffset === null ? strokeDashOffset : 0,\n                join: strokeLineJoin === null ? LINE_JOIN.MITER : strokeLineJoin as unknown as LINE_JOIN,\n                matrix: new Matrix(),\n                miterLimit: strokeMiterLimit === null ? 150 : strokeMiterLimit,\n                texture: strokeTexture || Texture.WHITE,\n                width: strokeWidth === null ? (typeof stroke === 'number' ? 1 : 0) : strokeWidth,\n                /* eslint-enable no-nested-ternary */\n            });\n        }\n\n        switch (element.nodeName.toLowerCase())\n        {\n            case 'circle':\n                (node as SVGGraphicsNode).embedCircle(element as SVGCircleElement);\n                break;\n            case 'ellipse':\n                (node as SVGGraphicsNode).embedEllipse(element as SVGEllipseElement);\n                break;\n            case 'image':\n                (node as SVGImageNode).embedImage(element as SVGImageElement);\n                break;\n            case 'line':\n                (node as SVGGraphicsNode).embedLine(element as SVGLineElement);\n                break;\n            case 'path':\n                (node as SVGPathNode).embedPath(element as SVGPathElement);\n                break;\n            case 'polyline':\n                (node as SVGGraphicsNode).embedPolyline(element as SVGPolylineElement);\n                break;\n            case 'polygon':\n                (node as SVGGraphicsNode).embedPolygon(element as SVGPolygonElement);\n                break;\n            case 'rect':\n                (node as SVGGraphicsNode).embedRect(element as SVGRectElement);\n                break;\n            case 'text':\n                (node as SVGTextNode).embedText(element as SVGTextElement);\n                break;\n            case 'use': {\n                const useElement = element as SVGUseElement;\n                const useTargetURL = useElement.getAttribute('href') || useElement.getAttribute('xlink:href');\n                const usePaint = this.queryPaint(useElement);\n\n                (node as SVGUseNode).embedUse(useElement);\n\n                if (useTargetURL.startsWith('#'))\n                {\n                    const useTarget = this.content.querySelector(useTargetURL);\n                    const contentNode = this.populateSceneRecursive(useTarget as SVGGraphicsElement, {\n                        basePaint: usePaint,\n                    }) as SVGGraphicsNode;\n\n                    (node as SVGUseNode).ref = contentNode;\n                    contentNode.transform.setFromMatrix(Matrix.IDENTITY);// clear transform\n                }\n                else if (!this._context.disableHrefSVGLoading)\n                {\n                    (node as SVGUseNode).isRefExternal = true;\n\n                    Loader._load(useTargetURL)\n                        .then((svgDocument) => [\n                            new SVGScene(svgDocument, {\n                                ...this._context,\n                                disableRootPopulation: true,\n                            }),\n                            svgDocument.querySelector('#' + useTargetURL.split('#')[1])\n                        ] as [SVGScene, SVGElement])\n                        .then(([shellScene, useTarget]) =>\n                        {\n                            if (!useTarget)\n                            {\n                                console.error(`SVGScene failed to resolve ${useTargetURL} and SVGUseNode is empty!`);\n                            }\n\n                            const contentNode = shellScene.populateSceneRecursive(useTarget as SVGGraphicsElement, {\n                                basePaint: usePaint,\n                            }) as SVGGraphicsNode;\n\n                            (node as SVGUseNode).ref = contentNode;\n                            contentNode.transform.setFromMatrix(Matrix.IDENTITY);// clear transform\n\n                            this._transformDirty = true;\n\n                            shellScene.on(TRANSFORM_DIRTY, () => {\n                                this._transformDirty = true;\n                            });\n                        });\n                }\n            }\n        }\n\n        node.transform.setFromMatrix(tempMatrix.set(\n            transformMatrix.a,\n            transformMatrix.b,\n            transformMatrix.c,\n            transformMatrix.d,\n            transformMatrix instanceof Matrix ? transformMatrix.tx : transformMatrix.e,\n            transformMatrix instanceof Matrix ? transformMatrix.ty : transformMatrix.f,\n        ));\n\n        if (element instanceof SVGMaskElement)\n        {\n            this._elementToMask.set(element, this.createMask(node));\n        }\n\n        const maskURL = element.getAttribute('mask');\n\n        if (maskURL)\n        {\n            const maskElement: SVGMaskElement = this.content.querySelector(this.parseReference(maskURL));\n\n            if (maskElement)\n            {\n                const maskServer = this.queryMask(maskElement);\n                const maskSprite = maskServer.createMask(node);\n\n                this.renderServers.addChild(maskServer);\n                node.mask = maskSprite;\n                node.addChild(maskSprite);\n            }\n        }\n\n        return {\n            paint,\n        };\n    }\n\n    /**\n     * Recursively populates a subscene graph that embeds {@code element}. The root of the subscene is returned.\n     *\n     * @param element - The SVGElement to be embedded.\n     * @param options - Inherited attributes from the element's parent, if any.\n     * @return The display object that embeds the element for rendering.\n     */\n    protected populateSceneRecursive(\n        element: SVGElement,\n        options?: {\n            basePaint?: Paint;\n        },\n    ): Container\n    {\n        const node = this.createNode(element);\n\n        if (!node)\n        {\n            return null;\n        }\n\n        node.on(NODE_TRANSFORM_DIRTY, this.onNodeTransformDirty);\n\n        let paint: Paint;\n\n        if (element instanceof SVGGraphicsElement || element instanceof SVGMaskElement)\n        {\n            const opts = this.embedIntoNode(node, element, options);\n\n            paint = opts.paint;\n        }\n\n        for (let i = 0, j = element.children.length; i < j; i++)\n        {\n            // eslint-disable-next-line\n            // @ts-ignore\n            const childNode = this.populateSceneRecursive(element.children[i], {\n                basePaint: paint,\n            });\n\n            if (childNode)\n            {\n                node.addChild(childNode);\n            }\n        }\n\n        if (node instanceof SVGGraphicsNode)\n        {\n            const bbox = node.getLocalBounds(tempRect);\n            const paintServers = node.paintServers;\n            const { x, y, width: bwidth, height: bheight } = bbox;\n\n            node.paintServers.forEach((paintServer) =>\n            {\n                paintServer.resolvePaintDimensions(bbox);\n            });\n\n            const geometry = node.geometry;\n            const graphicsData: GraphicsData[] = (geometry as any).graphicsData;\n\n            if (graphicsData)\n            {\n                graphicsData.forEach((data) =>\n                {\n                    const fillStyle = data.fillStyle;\n                    const lineStyle = data.lineStyle;\n\n                    if (fillStyle.texture && paintServers.find((server) => server.paintTexture === fillStyle.texture))\n                    {\n                        const width = fillStyle.texture.width;\n                        const height = fillStyle.texture.height;\n\n                        data.fillStyle.matrix\n                            .invert()\n                            .scale(bwidth / width, bheight / height)\n                            .invert();\n                    }\n                    if (fillStyle.matrix)\n                    {\n                        fillStyle.matrix\n                            .invert()\n                            .translate(x, y)\n                            .invert();\n                    }\n\n                    if (lineStyle.texture && paintServers.find((server) => server.paintTexture === lineStyle.texture))\n                    {\n                        const width = lineStyle.texture.width;\n                        const height = lineStyle.texture.height;\n\n                        data.lineStyle.matrix\n                            .invert()\n                            .scale(bwidth / width, bheight / height)\n                            .invert();\n                    }\n                    if (lineStyle.matrix)\n                    {\n                        lineStyle.matrix\n                            .invert()\n                            .translate(x, y)\n                            .invert();\n                    }\n                });\n\n                geometry.updateBatches();\n            }\n        }\n\n        if (element instanceof SVGMaskElement)\n        {\n            // Mask elements are *not* a part of the scene graph.\n            return null;\n        }\n\n        return node;\n    }\n\n    /**\n     * Populates the entire SVG scene. This should only be called once after the {@link SVGScene.content} has been set.\n     */\n    protected populateScene(): void\n    {\n        if (this.root)\n        {\n            this._cull.remove(this.root);\n        }\n\n        const root = this.populateSceneRecursive(this.content);\n\n        this.root = root;\n        this._cull.add(this.root);\n    }\n\n    /**\n     * Handles `nodetransformdirty` events fired by nodes. It will set {@link SVGScene._transformDirty} to true.\n     *\n     * This will also emit `transformdirty`.\n     */\n    private onNodeTransformDirty = (): void =>\n    {\n        this._transformDirty = true;\n        this.emit(TRANSFORM_DIRTY, this);\n    };\n\n    /**\n     * The width at which the SVG scene is being rendered. By default, this is the viewbox width specified by\n     * the root element.\n     */\n    get width(): number\n    {\n        return this._width;\n    }\n    set width(value: number)\n    {\n        this._width = value;\n        this.scale.x = this._width / this.content.viewBox.baseVal.width;\n    }\n\n    /**\n     * The height at which the SVG scene is being rendered. By default, this is the viewbox height specified by\n     * the root element.\n     */\n    get height(): number\n    {\n        return this._height;\n    }\n    set height(value: number)\n    {\n        this._height = value;\n        this.scale.y = this._height / this.content.viewBox.baseVal.height;\n    }\n\n    /**\n     * Load the SVG document and create a {@link SVGScene} asynchronously.\n     *\n     * A cache is used for loaded SVG documents.\n     *\n     * @param url\n     * @param context\n     * @returns\n     */\n    static async from(url: string, context?: SVGSceneContext): Promise<SVGScene> {\n        return new SVGScene(await Loader._load(url), context);\n    }\n}\n","import type { CanvasTextureAllocator } from '@pixi-essentials/texture-allocator';\n\n/**\n * Options to manage the SVG scene\n * \n * @public\n */\nexport interface SVGSceneContext\n{\n    /** The texture allocator for loading images. */\n    atlas: CanvasTextureAllocator;\n\n    /** Disable loading SVGs referenced from \"href\", \"xlink:href\" attributes of &lt;use /&gt; elements. */\n    disableHrefSVGLoading: boolean;\n\n    /** @ignore */\n    disableRootPopulation: boolean;\n}\n","import type { IPointData, Matrix } from '@pixi/math';\nimport type { TextStyle } from '@pixi/text';\n\n/**\n * The `SVGTextEngine` interface is used to layout text content authored in SVG files. The @pixi-essentials/svg\n * package provides {@link SVGTextEngineImpl} as a default implementation for users.\n *\n * Text engines are allowed to have async behaviour so that fonts can be loaded before text metrics are measured.\n *\n * It is expected an implementation inherits from {@link PIXI.DisplayObject}.\n *\n * @public\n * @see SVGTextEngineImpl\n */\nexport interface SVGTextEngine\n{\n    /**\n     * Clears the text content laid out already. This should reset the state of the engine to before any calls\n     * to {@link SVGTextEngine.put} were made.\n     */\n    clear(): Promise<void>;\n\n    /**\n     * Puts the text {@code content} into the local space of the engine at {@code position}. {@code matrix} can\n     * be used to transform the glyphs, although it is as optional feature for implementations.\n     *\n     * @param id - A locally unique ID that can be used to modify the added block of text later.\n     * @param position - The position of the text in the engine's local space.\n     * @param content - The text to add.\n     * @param style - The text styling applied.\n     * @param matrix\n     */\n    put(id: any, position: IPointData, content: string, style: Partial<TextStyle>, matrix?: Matrix): Promise<IPointData>;\n}\n"],"names":["_optionalChain","color","GradientFactory","FILL_RULE","Bounds","LINE_CAP","LINE_JOIN","GRAPHICS_CURVES","Point","SHAPES","GraphicsGeometry","Matrix","LineStyle","tempMatrix","Graphics","Texture","libtess","graphicsUtils","dPathParser","ColorMatrixFilter","Rectangle","Sprite","TextMetrics","TextStyle","Container","DisplayObject","Cull","CanvasTextureAllocator","RenderTexture","Loader._load"],"mappings":"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"}