{"version":3,"file":"texture-allocator.js","sources":["../src/AtlasResource.ts","../src/TextureAllocator.ts","../src/AtlasAllocator.ts","../src/CanvasTextureAllocator.ts","../src/RenderTextureAllocator.ts"],"sourcesContent":["import { ALPHA_MODES } from '@pixi/constants';\nimport { BaseTexture, GLTexture, Resource, Renderer } from '@pixi/core';\n\nimport type { Rectangle } from '@pixi/math';\nimport type { Texture } from '@pixi/core';\n\n/**\n * Types of image sources supported by {@link AtlasResource}.\n * \n * @public\n */\nexport type AtlasResourceSource =  HTMLImageElement | HTMLCanvasElement | ImageBitmap | ImageData | ArrayBufferView;\n\n/**\n * An item that is uploaded to the atlas texture.\n * \n * @public\n */\nexport type AtlasResourceItem =\n{\n    /**\n     * The location of the atlas item in the base-texture's space.\n     */\n    frame: Rectangle;\n\n    /**\n     * The source of the texture data.\n     */\n    source: AtlasResourceSource;\n\n    /**\n     * This flags when the resource is to be re-uploaded.\n     */\n    dirtyId: number;\n\n    /**\n     * This flags when the resource is uploaded and update-to-date with the dirty ID.\n     */\n    updateId: number;\n\n    /**\n     * The texture holding this item.\n     */\n    texture: Texture;\n};\n\n/**\n * An {@code AtlasResource} is used by {@link AtlasAllocator} to manage texture sources\n * \n * @public\n */\nexport class AtlasResource extends Resource\n{\n    /**\n     * The list of managed resources in the atlas.\n     */\n    public managedItems: AtlasResourceItem[];\n\n    /**\n     * Creates an atlas resource.\n     *\n     * @param width \n     * @param height \n     */\n    constructor(width: number, height: number)\n    {\n        super(width, height);\n\n        this.managedItems = [];\n    }\n\n    /**\n     * Uploads the atlas.\n     *\n     * @param renderer \n     * @param baseTexture \n     * @param glTexture \n     */\n    upload(renderer: Renderer, baseTexture: BaseTexture, glTexture: GLTexture): boolean\n    {\n        const gl: WebGLRenderingContext = renderer.gl;\n        const width = baseTexture.realWidth;\n        const height = baseTexture.realHeight;\n\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === ALPHA_MODES.UNPACK)\n\n        // Allocate the texture on the GPU\n        if (glTexture.width !== width ||\n            glTexture.height !== height)\n        {\n            glTexture.width = width;\n            glTexture.height = height;\n\n            gl.texImage2D(\n                baseTexture.target, \n                0, \n                baseTexture.format,\n                width,\n                height,\n                0,\n                baseTexture.format,\n                baseTexture.type,\n                undefined\n            );\n        }\n\n        const items = this.managedItems;\n\n        // Upload all atlas items.\n        for (let i = 0, j = items.length; i < j; i++)\n        {\n            this.uploadItem(\n                renderer,\n                baseTexture.target,\n                baseTexture.format,\n                baseTexture.type,\n                items[i]\n            );\n        }\n\n        return true;\n    }\n\n    /**\n     * Uploads the atlas item to the GPU.\n     *\n     * @param renderer - The renderer holding the WebGL context.\n     * @param target - The binding point of the base-texture.\n     * @param format - The format of the base-texture.\n     * @param type - The type of the base-texture data.\n     * @param item - The item to upload.\n     */\n    protected uploadItem(\n        renderer: Renderer, \n        target: number,\n        format: number,\n        type: number,\n        item: AtlasResourceItem\n    ): void\n    {\n        if (item.updateId === item.dirtyId)\n        {\n            return;\n        }\n\n        const gl: WebGLRenderingContext = renderer.gl;\n        const isWebGL2 = (gl instanceof WebGL2RenderingContext);\n        const frame = item.frame;\n        let source = item.source;\n\n        // if WebGL1, convert whatever we have into a typed array\n        if (!isWebGL2) {\n            if (source instanceof ImageData) {\n                source = source.data;  // pass the typed array directly\n            } else if (source instanceof HTMLCanvasElement) {\n                const ctx = source.getContext('2d');\n                const [w, h] = [source.width, source.height];\n                source = ctx.getImageData(0, 0, w, h).data;\n            } else if (source instanceof HTMLImageElement) {\n                const [w, h] = [source.naturalWidth, source.naturalHeight];\n                const canvas = document.createElement('canvas');\n                canvas.width = w;\n                canvas.height = h;\n\n                const ctx = canvas.getContext('2d');\n                ctx.drawImage(source, 0, 0);\n                source = ctx.getImageData(0, 0, w, h).data;\n            }\n        }\n\n        gl.texSubImage2D(\n            target,\n            0,\n            frame.x,\n            frame.y,\n            frame.width,\n            frame.height,\n            format,\n            type,\n            source as any,\n        );\n\n        item.updateId = item.dirtyId;\n    }\n}","import { BaseTexture, Texture } from '@pixi/core';\nimport { GuilloteneAllocator } from '@pixi-essentials/area-allocator';\nimport { Rectangle } from '@pixi/math';\n\nimport type { TextureSlab } from './TextureSlab';\n\nconst tempRect = new Rectangle();\n\n/**\n * The texture allocator dynamically manages space on base-texture slabs. It can be used to generate\n * atlases on demand, which improve batching efficiency.\n * \n * @public\n */\nexport class TextureAllocator<T extends Texture = Texture>\n{\n    /**\n     * The width of texture slabs.\n     */\n    public readonly slabWidth: number;\n\n    /**\n     * The height of texture slabs.\n     */\n    public readonly slabHeight: number;\n\n    /**\n     * The list of base-textures that are used to allocate texture space.\n     */\n    protected textureSlabs: TextureSlab[];\n\n    /**\n     * @param slabWidth - The width of base-texture slabs. This should be at most 2048.\n     * @param slabHeight - The height of base-texture slabs. This should be at most 2048.\n     */\n    constructor(slabWidth = 2048, slabHeight = 2048)\n    {\n        this.slabWidth = slabWidth;\n        this.slabHeight = slabHeight;\n\n        this.textureSlabs = [];\n    }\n\n    get maxWidth() {\n        return this.slabWidth - (2 * this.calculatePadding(this.slabWidth, this.slabHeight));\n    }\n\n    get maxHeight() {\n        return this.slabHeight - (2 * this.calculatePadding(this.slabWidth, this.slabHeight));\n    }\n\n    /**\n     * Allocates a texture from this allocator. \n     * \n     * If its existing slab pool has enough space, the texture is issued from one. Otherwise,\n     * a new slab is created and the texture is issued from it. However, if the requested\n     * dimensions are larger than slabs themselves, then `null` is always returned.\n     * \n     * To upload a texture source, you will have to create an atlas-managing {@link Resource}\n     * yourself on the base-texture. The {@link AtlasAllocator} does this for you, while the\n     * {@link CanvasTextureAllocator} can be used to draw on a canvas-based atlas.\n     *\n     * @param width - The width of the requested texture.\n     * @param height - The height of the requested texture.\n     * @param padding - The padding requested around the texture, to prevent bleeding.\n     * @return The allocated texture, if successful; otherwise, `null`.\n     */\n    allocate(width: number, height: number, padding = this.calculatePadding(width, height)): T\n    {\n        // Cannot allocate a texture larger than a texture-slab.\n        if (width + 2 * padding > this.slabWidth || \n                height + 2 * padding > this.slabHeight)\n        {\n            return null;\n        }\n\n        const slabs = this.textureSlabs;\n\n        // Loop through the slabs and find one with enough space, if any.\n        for (let i = 0, j = slabs.length; i < j; i++)\n        {\n            const slab = slabs[i];\n            const texture = this.issueTexture(slab, width, height, padding);\n\n            if (texture)\n            {\n                return texture;\n            }\n        }\n\n        // Issue a new slab.\n        const slab = this.createSlab();\n\n        // Append this slab to the head of the list.\n        this.textureSlabs.unshift(slab);\n\n        // Issue the texture from this blank slab.\n        return this.issueTexture(slab, width, height, padding);\n    }\n\n    /**\n     * Frees the texture and reclaims its space. It is assumed you will not use it again, and have\n     * destroyed any resource uploading its data.\n     *\n     * @param texture \n     * @throws When the texture was not located in this allocator.\n     */\n    free(texture: T): void\n    {\n        const baseTexture = (texture as Texture).baseTexture;\n        const slab = this.textureSlabs.find(sl => sl.slab === baseTexture);\n\n        if (!slab)\n        {\n            throw new Error(\"The texture cannot be freed because \" + \n                \"its base-texture is not pooled by this allocator. \" +\n                \"This is either a bug in TextureAllocator or you tried to free a \" +\n                \"texture that was never allocated by one.\");\n        }\n\n        const textureEntry = slab.managedTextures.find(entry => entry.texture === texture);\n\n        if (!textureEntry)\n        {\n            throw new Error(\"The texture cannot be freed because it was not found \" +\n                \"in the managed list of issued textures on its slab. This may be because you \" +\n                \"duplicated this texture or a bug in TextureAllocator\");\n        }\n\n        slab.managedArea.free(textureEntry.area);\n        slab.managedTextures.splice(slab.managedTextures.indexOf(textureEntry), 1);\n    }\n\n    protected calculatePadding(width: number, height: number): number\n    {\n        const dimen = Math.max(width, height);\n\n        if (dimen < 64)\n        {\n            return 2;\n        }\n        else if (dimen < 128)\n        {\n            return 4;\n        }\n        else if (dimen < 1024)\n        {\n            return 8;\n        }\n        else\n        {\n            return 16;\n        }\n    }\n\n    /**\n     * Creates a texture slab. The slab's base-texture is not backed by any resource. You\n     * will have to manage that yourself. See {@link AtlasAllocator} or {@link CanvasTextureAllocator}\n     * for better resource semantics.\n     */\n    protected createSlab(): TextureSlab\n    {\n        return {\n            managedArea: new GuilloteneAllocator(this.slabWidth, this.slabHeight),\n            managedTextures: [],\n            slab: new BaseTexture(null,\n            {\n                width: this.slabWidth,\n                height: this.slabHeight,\n            }),\n        };\n    }\n\n    /**\n     * Creates a texture on the given base-texture at {@code frame}.\n     *\n     * @param baseTexture - The base texture that will hold the texture's space.\n     * @param frame - The frame in which the texture will be stored.\n     */\n    protected createTexture(baseTexture: BaseTexture, frame: Rectangle): T\n    {\n        // Override this method to return correct texture type T.\n        return new Texture(baseTexture, frame) as T;\n    }\n\n    /**\n     * Issues a texture from the given texture slab, if possible.\n     *\n     * @param slab - The texture slab to allocate frame.\n     * @param width - The width of the requested texture.\n     * @param height - The height of the requested texture.\n     * @param padding - Padding required around the texture.\n     * @return The issued texture, if successful; otherwise, `null`.\n     */\n    protected issueTexture(slab: TextureSlab, width: number, height: number, padding = 0): T\n    {\n        const area = slab.managedArea.allocate(width + 2 * padding, height + 2 * padding);\n\n        if (!area)\n        {\n            return null;\n        }\n\n        tempRect.copyFrom(area);\n        tempRect.pad(-padding);\n\n        const baseTexture = slab.slab;\n        const issuedTexture = this.createTexture(baseTexture, tempRect.clone());\n\n        slab.managedTextures.push({\n            area,\n            texture: issuedTexture,\n        });\n\n        return issuedTexture;\n    }\n}","import { AtlasResource } from './AtlasResource';\nimport { BaseTexture, Texture } from '@pixi/core';\nimport { GuilloteneAllocator } from '@pixi-essentials/area-allocator';\nimport { TextureAllocator } from './TextureAllocator';\nimport { TextureSlab } from './TextureSlab';\n\nimport type { AtlasResourceSource } from './AtlasResource';\n\n/**\n * This texture allocator auto-manages the base-texture with an {@link AtlasResource}. You can also\n * pass a texture source to `allocate`, mimicing {@link Texture.from} functionality.\n * \n * @public\n */\nexport class AtlasAllocator extends TextureAllocator\n{\n    /**\n     * Creates a texture slab backed by an {@link AtlasResource}.\n     */\n    protected createSlab(): TextureSlab\n    {\n        return {\n            managedArea: new GuilloteneAllocator(this.slabWidth, this.slabHeight),\n            managedTextures: [],\n            slab: new BaseTexture(new AtlasResource(this.slabWidth, this.slabHeight),\n            {\n                width: this.slabWidth,\n                height: this.slabHeight,\n            }),\n        };\n    }\n\n    /**\n     * Allocates a texture backed by the given atlas source, with the given padding.\n     *\n     * @override\n     * @param width \n     * @param height \n     * @param padding \n     * @param source \n     */\n    allocate(width: number, height: number, padding?: number, source?: AtlasResourceSource): Texture;\n\n    /**\n     * Allocates a texture backed by the given source, with default padding.\n     *\n     * @param width\n     * @param height \n     * @param source \n     */\n    allocate(width: number, height: number, source?: AtlasResourceSource): Texture;\n\n    allocate(width: number, height: number, paddingOrSource?: number | AtlasResourceSource, source?: AtlasResourceSource): Texture\n    {\n        let padding: number;\n\n        if (typeof paddingOrSource === 'number')\n        {\n            padding = paddingOrSource;\n        }\n        else\n        {\n            padding = this.calculatePadding(width, height);\n            source = paddingOrSource;\n        }\n\n        const texture = super.allocate(width, height, padding);\n\n        if (source)\n        {\n            const atlas = texture.baseTexture.resource as AtlasResource;\n            const item = {\n                frame: texture.frame,\n                source,\n                // dirtyId !== updateId only if image loaded\n                dirtyId: source instanceof HTMLImageElement && !source.complete ? -1 : 0,\n                updateId: -1,\n                texture,\n            };\n\n            atlas.managedItems.push(item);\n\n            if (source instanceof HTMLImageElement && !source.complete) {\n                source.addEventListener('load', () => {\n                    if (texture.baseTexture.valid && !texture.baseTexture.destroyed && atlas.managedItems.indexOf(item) >= 0) {\n                        item.dirtyId++;\n                        texture.baseTexture.update();\n                    }\n                });\n            }\n\n            texture.baseTexture.update();\n        }\n\n        return texture;\n    }\n\n    free(texture: Texture): void\n    {\n        super.free(texture);\n\n        const atlas = texture.baseTexture.resource as AtlasResource;\n        const item = atlas.managedItems.find(item => item.texture === texture);\n\n        if (item)\n        {\n            atlas.managedItems.splice(atlas.managedItems.indexOf(item), 1);\n        }\n    }\n}","import { GuilloteneAllocator } from '@pixi-essentials/area-allocator';\nimport { BaseTexture } from '@pixi/core';\nimport { TextureAllocator } from './TextureAllocator';\nimport { TextureSlab } from './TextureSlab';\n\n/**\n * This allocator issues texture backed by a canvas. You can draw on to that canvas to soruce\n * each texture.\n * \n * @public\n */\nexport class CanvasTextureAllocator extends TextureAllocator\n{\n    /**\n     * Creates a texture slab backed by a canvas.\n     */\n    protected createSlab(): TextureSlab\n    {\n        const canvas = document.createElement('canvas');\n\n        canvas.width = this.slabWidth;\n        canvas.height = this.slabHeight;\n\n        return {\n            managedArea: new GuilloteneAllocator(this.slabWidth, this.slabHeight),\n            managedTextures: [],\n            slab: new BaseTexture(canvas, {\n                width: this.slabWidth,\n                height: this.slabHeight\n            })\n        };\n    }\n}","import { BaseRenderTexture, RenderTexture } from '@pixi/core';\nimport { GuilloteneAllocator } from '@pixi-essentials/area-allocator';\nimport { TextureAllocator } from './TextureAllocator';\n\nimport type { BaseTexture } from '@pixi/core';\nimport type { Rectangle } from '@pixi/math';\nimport type { TextureSlab } from './TextureSlab';\n\n/**\n * This allocator issues render-textures, and is otherwise just like {@link TextureAllocator}.\n * \n * @public\n */\nexport class RenderTextureAllocator extends TextureAllocator<RenderTexture>\n{\n    /**\n     * Creates a texture slab backed by a base render-texture.\n     */\n    protected createSlab(): TextureSlab\n    {\n        return {\n            managedArea: new GuilloteneAllocator(this.slabWidth, this.slabHeight),\n            managedTextures: [],\n            slab: new BaseRenderTexture({\n                width: this.slabWidth,\n                height: this.slabHeight\n            })\n        };\n    }\n\n    /**\n     * Creates a render-texture from the given base render-texture.\n     *\n     * @param baseTexture \n     * @param frame \n     */\n    protected createTexture(baseTexture: BaseTexture, frame: Rectangle): RenderTexture\n    {\n        return new RenderTexture(baseTexture as BaseRenderTexture, frame);\n    }\n}"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChNA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACxBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;"}