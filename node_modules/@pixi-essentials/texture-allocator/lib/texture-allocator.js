/* eslint-disable */
 
/*!
 * @pixi-essentials/texture-allocator - v2.0.1
 * Compiled Sun, 16 Apr 2023 20:50:45 UTC
 *
 * @pixi-essentials/texture-allocator is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2019-2020, Shukant K. Pal <shukantpal@outlook.com>, All Rights Reserved
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var constants = require('@pixi/constants');
var core = require('@pixi/core');
var areaAllocator = require('@pixi-essentials/area-allocator');
var math = require('@pixi/math');

/**
 * Types of image sources supported by {@link AtlasResource}.
 * 
 * @public
 */



































/**
 * An {@code AtlasResource} is used by {@link AtlasAllocator} to manage texture sources
 * 
 * @public
 */
class AtlasResource extends core.Resource
{
    /**
     * The list of managed resources in the atlas.
     */
    

    /**
     * Creates an atlas resource.
     *
     * @param width 
     * @param height 
     */
    constructor(width, height)
    {
        super(width, height);

        this.managedItems = [];
    }

    /**
     * Uploads the atlas.
     *
     * @param renderer 
     * @param baseTexture 
     * @param glTexture 
     */
    upload(renderer, baseTexture, glTexture)
    {
        const gl = renderer.gl;
        const width = baseTexture.realWidth;
        const height = baseTexture.realHeight;

        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, baseTexture.alphaMode === constants.ALPHA_MODES.UNPACK);

        // Allocate the texture on the GPU
        if (glTexture.width !== width ||
            glTexture.height !== height)
        {
            glTexture.width = width;
            glTexture.height = height;

            gl.texImage2D(
                baseTexture.target, 
                0, 
                baseTexture.format,
                width,
                height,
                0,
                baseTexture.format,
                baseTexture.type,
                undefined
            );
        }

        const items = this.managedItems;

        // Upload all atlas items.
        for (let i = 0, j = items.length; i < j; i++)
        {
            this.uploadItem(
                renderer,
                baseTexture.target,
                baseTexture.format,
                baseTexture.type,
                items[i]
            );
        }

        return true;
    }

    /**
     * Uploads the atlas item to the GPU.
     *
     * @param renderer - The renderer holding the WebGL context.
     * @param target - The binding point of the base-texture.
     * @param format - The format of the base-texture.
     * @param type - The type of the base-texture data.
     * @param item - The item to upload.
     */
     uploadItem(
        renderer, 
        target,
        format,
        type,
        item
    )
    {
        if (item.updateId === item.dirtyId)
        {
            return;
        }

        const gl = renderer.gl;
        const isWebGL2 = (gl instanceof WebGL2RenderingContext);
        const frame = item.frame;
        let source = item.source;

        // if WebGL1, convert whatever we have into a typed array
        if (!isWebGL2) {
            if (source instanceof ImageData) {
                source = source.data;  // pass the typed array directly
            } else if (source instanceof HTMLCanvasElement) {
                const ctx = source.getContext('2d');
                const [w, h] = [source.width, source.height];
                source = ctx.getImageData(0, 0, w, h).data;
            } else if (source instanceof HTMLImageElement) {
                const [w, h] = [source.naturalWidth, source.naturalHeight];
                const canvas = document.createElement('canvas');
                canvas.width = w;
                canvas.height = h;

                const ctx = canvas.getContext('2d');
                ctx.drawImage(source, 0, 0);
                source = ctx.getImageData(0, 0, w, h).data;
            }
        }

        gl.texSubImage2D(
            target,
            0,
            frame.x,
            frame.y,
            frame.width,
            frame.height,
            format,
            type,
            source ,
        );

        item.updateId = item.dirtyId;
    }
}

const tempRect = new math.Rectangle();

/**
 * The texture allocator dynamically manages space on base-texture slabs. It can be used to generate
 * atlases on demand, which improve batching efficiency.
 * 
 * @public
 */
class TextureAllocator
{
    /**
     * The width of texture slabs.
     */
    

    /**
     * The height of texture slabs.
     */
    

    /**
     * The list of base-textures that are used to allocate texture space.
     */
    

    /**
     * @param slabWidth - The width of base-texture slabs. This should be at most 2048.
     * @param slabHeight - The height of base-texture slabs. This should be at most 2048.
     */
    constructor(slabWidth = 2048, slabHeight = 2048)
    {
        this.slabWidth = slabWidth;
        this.slabHeight = slabHeight;

        this.textureSlabs = [];
    }

    get maxWidth() {
        return this.slabWidth - (2 * this.calculatePadding(this.slabWidth, this.slabHeight));
    }

    get maxHeight() {
        return this.slabHeight - (2 * this.calculatePadding(this.slabWidth, this.slabHeight));
    }

    /**
     * Allocates a texture from this allocator. 
     * 
     * If its existing slab pool has enough space, the texture is issued from one. Otherwise,
     * a new slab is created and the texture is issued from it. However, if the requested
     * dimensions are larger than slabs themselves, then `null` is always returned.
     * 
     * To upload a texture source, you will have to create an atlas-managing {@link Resource}
     * yourself on the base-texture. The {@link AtlasAllocator} does this for you, while the
     * {@link CanvasTextureAllocator} can be used to draw on a canvas-based atlas.
     *
     * @param width - The width of the requested texture.
     * @param height - The height of the requested texture.
     * @param padding - The padding requested around the texture, to prevent bleeding.
     * @return The allocated texture, if successful; otherwise, `null`.
     */
    allocate(width, height, padding = this.calculatePadding(width, height))
    {
        // Cannot allocate a texture larger than a texture-slab.
        if (width + 2 * padding > this.slabWidth || 
                height + 2 * padding > this.slabHeight)
        {
            return null;
        }

        const slabs = this.textureSlabs;

        // Loop through the slabs and find one with enough space, if any.
        for (let i = 0, j = slabs.length; i < j; i++)
        {
            const slab = slabs[i];
            const texture = this.issueTexture(slab, width, height, padding);

            if (texture)
            {
                return texture;
            }
        }

        // Issue a new slab.
        const slab = this.createSlab();

        // Append this slab to the head of the list.
        this.textureSlabs.unshift(slab);

        // Issue the texture from this blank slab.
        return this.issueTexture(slab, width, height, padding);
    }

    /**
     * Frees the texture and reclaims its space. It is assumed you will not use it again, and have
     * destroyed any resource uploading its data.
     *
     * @param texture 
     * @throws When the texture was not located in this allocator.
     */
    free(texture)
    {
        const baseTexture = (texture ).baseTexture;
        const slab = this.textureSlabs.find(sl => sl.slab === baseTexture);

        if (!slab)
        {
            throw new Error("The texture cannot be freed because " + 
                "its base-texture is not pooled by this allocator. " +
                "This is either a bug in TextureAllocator or you tried to free a " +
                "texture that was never allocated by one.");
        }

        const textureEntry = slab.managedTextures.find(entry => entry.texture === texture);

        if (!textureEntry)
        {
            throw new Error("The texture cannot be freed because it was not found " +
                "in the managed list of issued textures on its slab. This may be because you " +
                "duplicated this texture or a bug in TextureAllocator");
        }

        slab.managedArea.free(textureEntry.area);
        slab.managedTextures.splice(slab.managedTextures.indexOf(textureEntry), 1);
    }

     calculatePadding(width, height)
    {
        const dimen = Math.max(width, height);

        if (dimen < 64)
        {
            return 2;
        }
        else if (dimen < 128)
        {
            return 4;
        }
        else if (dimen < 1024)
        {
            return 8;
        }
        else
        {
            return 16;
        }
    }

    /**
     * Creates a texture slab. The slab's base-texture is not backed by any resource. You
     * will have to manage that yourself. See {@link AtlasAllocator} or {@link CanvasTextureAllocator}
     * for better resource semantics.
     */
     createSlab()
    {
        return {
            managedArea: new areaAllocator.GuilloteneAllocator(this.slabWidth, this.slabHeight),
            managedTextures: [],
            slab: new core.BaseTexture(null,
            {
                width: this.slabWidth,
                height: this.slabHeight,
            }),
        };
    }

    /**
     * Creates a texture on the given base-texture at {@code frame}.
     *
     * @param baseTexture - The base texture that will hold the texture's space.
     * @param frame - The frame in which the texture will be stored.
     */
     createTexture(baseTexture, frame)
    {
        // Override this method to return correct texture type T.
        return new core.Texture(baseTexture, frame) ;
    }

    /**
     * Issues a texture from the given texture slab, if possible.
     *
     * @param slab - The texture slab to allocate frame.
     * @param width - The width of the requested texture.
     * @param height - The height of the requested texture.
     * @param padding - Padding required around the texture.
     * @return The issued texture, if successful; otherwise, `null`.
     */
     issueTexture(slab, width, height, padding = 0)
    {
        const area = slab.managedArea.allocate(width + 2 * padding, height + 2 * padding);

        if (!area)
        {
            return null;
        }

        tempRect.copyFrom(area);
        tempRect.pad(-padding);

        const baseTexture = slab.slab;
        const issuedTexture = this.createTexture(baseTexture, tempRect.clone());

        slab.managedTextures.push({
            area,
            texture: issuedTexture,
        });

        return issuedTexture;
    }
}

/**
 * This texture allocator auto-manages the base-texture with an {@link AtlasResource}. You can also
 * pass a texture source to `allocate`, mimicing {@link Texture.from} functionality.
 * 
 * @public
 */
class AtlasAllocator extends TextureAllocator
{
    /**
     * Creates a texture slab backed by an {@link AtlasResource}.
     */
     createSlab()
    {
        return {
            managedArea: new areaAllocator.GuilloteneAllocator(this.slabWidth, this.slabHeight),
            managedTextures: [],
            slab: new core.BaseTexture(new AtlasResource(this.slabWidth, this.slabHeight),
            {
                width: this.slabWidth,
                height: this.slabHeight,
            }),
        };
    }

    /**
     * Allocates a texture backed by the given atlas source, with the given padding.
     *
     * @override
     * @param width 
     * @param height 
     * @param padding 
     * @param source 
     */
    










    allocate(width, height, paddingOrSource, source)
    {
        let padding;

        if (typeof paddingOrSource === 'number')
        {
            padding = paddingOrSource;
        }
        else
        {
            padding = this.calculatePadding(width, height);
            source = paddingOrSource;
        }

        const texture = super.allocate(width, height, padding);

        if (source)
        {
            const atlas = texture.baseTexture.resource ;
            const item = {
                frame: texture.frame,
                source,
                // dirtyId !== updateId only if image loaded
                dirtyId: source instanceof HTMLImageElement && !source.complete ? -1 : 0,
                updateId: -1,
                texture,
            };

            atlas.managedItems.push(item);

            if (source instanceof HTMLImageElement && !source.complete) {
                source.addEventListener('load', () => {
                    if (texture.baseTexture.valid && !texture.baseTexture.destroyed && atlas.managedItems.indexOf(item) >= 0) {
                        item.dirtyId++;
                        texture.baseTexture.update();
                    }
                });
            }

            texture.baseTexture.update();
        }

        return texture;
    }

    free(texture)
    {
        super.free(texture);

        const atlas = texture.baseTexture.resource ;
        const item = atlas.managedItems.find(item => item.texture === texture);

        if (item)
        {
            atlas.managedItems.splice(atlas.managedItems.indexOf(item), 1);
        }
    }
}

/**
 * This allocator issues texture backed by a canvas. You can draw on to that canvas to soruce
 * each texture.
 * 
 * @public
 */
class CanvasTextureAllocator extends TextureAllocator
{
    /**
     * Creates a texture slab backed by a canvas.
     */
     createSlab()
    {
        const canvas = document.createElement('canvas');

        canvas.width = this.slabWidth;
        canvas.height = this.slabHeight;

        return {
            managedArea: new areaAllocator.GuilloteneAllocator(this.slabWidth, this.slabHeight),
            managedTextures: [],
            slab: new core.BaseTexture(canvas, {
                width: this.slabWidth,
                height: this.slabHeight
            })
        };
    }
}

/**
 * This allocator issues render-textures, and is otherwise just like {@link TextureAllocator}.
 * 
 * @public
 */
class RenderTextureAllocator extends TextureAllocator
{
    /**
     * Creates a texture slab backed by a base render-texture.
     */
     createSlab()
    {
        return {
            managedArea: new areaAllocator.GuilloteneAllocator(this.slabWidth, this.slabHeight),
            managedTextures: [],
            slab: new core.BaseRenderTexture({
                width: this.slabWidth,
                height: this.slabHeight
            })
        };
    }

    /**
     * Creates a render-texture from the given base render-texture.
     *
     * @param baseTexture 
     * @param frame 
     */
     createTexture(baseTexture, frame)
    {
        return new core.RenderTexture(baseTexture , frame);
    }
}

exports.AtlasAllocator = AtlasAllocator;
exports.AtlasResource = AtlasResource;
exports.CanvasTextureAllocator = CanvasTextureAllocator;
exports.RenderTextureAllocator = RenderTextureAllocator;
exports.TextureAllocator = TextureAllocator;
//# sourceMappingURL=texture-allocator.js.map
