{"version":3,"file":"gradients.js","sources":["../src/GradientFactory.ts"],"sourcesContent":["import { Rectangle } from '@pixi/math';\nimport { RenderTexture, Texture } from '@pixi/core';\nimport { Sprite } from '@pixi/sprite';\n\nimport type { ColorStop } from './ColorStop';\nimport type { Renderer } from '@pixi/core';\n\n/**\n * Converts a hexadecimal color into a CSS color string.\n * \n * @ignore\n * @param color - The hexadecimal form of the color.\n */\nfunction cssColor(color: number | string) {\n    if(typeof color === 'string'){\n        return color;\n    }\n    let string = color.toString(16);\n\n    while (string.length < 6) {\n        string = `0${string}`;\n    }\n\n    return `#${string}`;\n}\n\nconst tempSourceFrame = new Rectangle();\nconst tempDestinationFrame = new Rectangle();\n\n/**\n * Factory class for generating color-gradient textures.\n * \n * @public\n */\nexport class GradientFactory\n{\n    /**\n     * Renders a linear-gradient into `renderTexture` that starts from (x0, y0) and ends at (x1, y1). These\n     * coordinates are defined in the **texture's space**. That means only the frame (0, 0, `renderTexture.width`, `renderTexture.height`)\n     * will be rendered.\n     * \n     * This method can be called inside a render cycle, and will preserve the renderer state. However, the current implementation\n     * causes a batch renderer flush.\n     * \n     * @param renderer - The renderer to use for drawing the gradient.\n     * @param renderTexture - The texture to render the gradient into.\n     * @param options - The gradient parameters.\n     * @param options.x0 - The x-coordinate of the gradient's start point.\n     * @param options.y0 - The y-coordinate of the gradient's start point.\n     * @param options.x1 - The x-coordinate of the gradient's end point.\n     * @param options.y1 - The y-coordinate of the gradient's end point.\n     * @param options.colorStops - The color stops along the gradient pattern.\n     * @todo This implementation is currently using the Canvas API (slow). It will be converted to a WebGL shader.\n     * @todo This implementation causes a batch renderer flush. This will be optimized in a future release.\n     */\n    static createLinearGradient(\n        renderer: Renderer, \n        renderTexture: RenderTexture, \n        options: {\n            x0: number,\n            y0: number,\n            x1: number,\n            y1: number,\n            colorStops: ColorStop[]\n        }\n    ): RenderTexture\n    {\n        const { x0, y0, x1, y1, colorStops } = options;\n\n        const canvas = document.createElement('canvas');\n\n        canvas.width = renderTexture.width;\n        canvas.height = renderTexture.height;\n\n        const context = canvas.getContext('2d');\n\n        const gradient = context.createLinearGradient(x0, y0, x1, y1);\n\n        colorStops.forEach((stop) => {\n            gradient.addColorStop(stop.offset, cssColor(stop.color));\n        });\n\n        context.fillStyle = gradient;\n        context.fillRect(0, 0, renderTexture.width, renderTexture.height);\n\n        // Store the current render-texture binding.\n        const renderTarget = renderer.renderTexture.current;\n        const sourceFrame = tempSourceFrame.copyFrom(renderer.renderTexture.sourceFrame);\n        const destinationFrame = tempDestinationFrame.copyFrom(renderer.renderTexture.destinationFrame);\n\n        const renderSprite = new Sprite(Texture.from(canvas));\n\n        renderer.batch.flush();\n\n        renderer.renderTexture.bind(renderTexture);\n        renderSprite.render(renderer);\n        \n        renderer.batch.flush();\n        renderer.renderTexture.bind(renderTarget, sourceFrame, destinationFrame);\n\n        return renderTexture;\n    }\n\n    /**\n     * Renders a radial-gradient into `renderTexture` that starts at the circle centered at (x0, y0) of radius r0 and\n     * ends at the circle centered at (x1, y1) of radius r1.\n     * \n     * This method can be called inside a render cycle, and will preserve the renderer state. However, the current implementation\n     * causes a batch renderer flush.\n     * \n     * @param renderer - The renderer to use for drawing the gradient.\n     * @param renderTexture - The texture to render the gradient into.\n     * @param options - The gradient parameters.\n     * @param options.x0 - The x-coordinate of the starting circle's center.\n     * @param options.y0 - The y-coordinate of the starting circle's center.\n     * @param options.r0 - The radius of the starting circle.\n     * @param options.x1 - The x-coordinate of the ending circle's center.\n     * @param options.y1 - The y-coordinate of the ending circle's center.\n     * @param options.colorStops - The color stops along the gradient pattern.\n     * @todo This implementation is currently using the Canvas API (slow). It will be converted to a WebGL shader.\n     * @todo This implementation causes a batch renderer flush. This will be optimized in a future release.\n     */\n    static createRadialGradient(\n        renderer: Renderer, \n        renderTexture: RenderTexture, \n        options: {\n            x0: number,\n            y0: number,\n            r0: number,\n            x1: number,\n            y1: number,\n            r1: number,\n            colorStops: ColorStop[]\n        }\n    ): RenderTexture\n    {\n        const { x0, y0, r0, x1, y1, r1, colorStops } = options;\n\n        const canvas = document.createElement('canvas');\n\n        canvas.width = renderTexture.width;\n        canvas.height = renderTexture.height;\n\n        const context = canvas.getContext('2d');\n\n        const gradient = context.createRadialGradient(x0, y0, r0, x1, y1, r1);\n\n        colorStops.forEach((stop) => {\n            gradient.addColorStop(stop.offset, cssColor(stop.color));\n        });\n\n        context.fillStyle = gradient;\n        context.fillRect(0, 0, renderTexture.width, renderTexture.height);\n\n        // Store the current render-texture binding.\n        const renderTarget = renderer.renderTexture.current;\n        const sourceFrame = tempSourceFrame.copyFrom(renderer.renderTexture.sourceFrame);\n        const destinationFrame = tempDestinationFrame.copyFrom(renderer.renderTexture.destinationFrame);\n\n        const renderSprite = new Sprite(Texture.from(canvas));\n\n        renderer.batch.flush();\n\n        renderer.renderTexture.bind(renderTexture);\n        renderSprite.render(renderer);\n        \n        renderer.batch.flush();\n        renderer.renderTexture.bind(renderTarget, sourceFrame, destinationFrame);\n\n        return renderTexture;\n    }\n}"],"names":["Rectangle","Sprite","Texture"],"mappings":"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"}