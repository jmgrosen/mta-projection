/* eslint-disable */
 
/*!
 * @pixi-essentials/gradients - v0.0.5
 * Compiled Sun, 05 Mar 2023 03:07:48 UTC
 *
 * @pixi-essentials/gradients is licensed under the MIT License.
 * http://www.opensource.org/licenses/mit-license
 * 
 * Copyright 2019-2020, Shukant K. Pal <shukantpal@outlook.com>, All Rights Reserved
 */
this.PIXI = this.PIXI || {};
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@pixi/math'), require('@pixi/core'), require('@pixi/sprite')) :
    typeof define === 'function' && define.amd ? define(['exports', '@pixi/math', '@pixi/core', '@pixi/sprite'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global._pixi_essentials_gradients = {}, global.PIXI, global.PIXI, global.PIXI));
})(this, (function (exports, math, core, sprite) { 'use strict';

    /**
     * Converts a hexadecimal color into a CSS color string.
     * 
     * @ignore
     * @param color - The hexadecimal form of the color.
     */
    function cssColor(color) {
        if(typeof color === 'string'){
            return color;
        }
        let string = color.toString(16);

        while (string.length < 6) {
            string = `0${string}`;
        }

        return `#${string}`;
    }

    const tempSourceFrame = new math.Rectangle();
    const tempDestinationFrame = new math.Rectangle();

    /**
     * Factory class for generating color-gradient textures.
     * 
     * @public
     */
    class GradientFactory
    {
        /**
         * Renders a linear-gradient into `renderTexture` that starts from (x0, y0) and ends at (x1, y1). These
         * coordinates are defined in the **texture's space**. That means only the frame (0, 0, `renderTexture.width`, `renderTexture.height`)
         * will be rendered.
         * 
         * This method can be called inside a render cycle, and will preserve the renderer state. However, the current implementation
         * causes a batch renderer flush.
         * 
         * @param renderer - The renderer to use for drawing the gradient.
         * @param renderTexture - The texture to render the gradient into.
         * @param options - The gradient parameters.
         * @param options.x0 - The x-coordinate of the gradient's start point.
         * @param options.y0 - The y-coordinate of the gradient's start point.
         * @param options.x1 - The x-coordinate of the gradient's end point.
         * @param options.y1 - The y-coordinate of the gradient's end point.
         * @param options.colorStops - The color stops along the gradient pattern.
         * @todo This implementation is currently using the Canvas API (slow). It will be converted to a WebGL shader.
         * @todo This implementation causes a batch renderer flush. This will be optimized in a future release.
         */
        static createLinearGradient(
            renderer, 
            renderTexture, 
            options






        )
        {
            const { x0, y0, x1, y1, colorStops } = options;

            const canvas = document.createElement('canvas');

            canvas.width = renderTexture.width;
            canvas.height = renderTexture.height;

            const context = canvas.getContext('2d');

            const gradient = context.createLinearGradient(x0, y0, x1, y1);

            colorStops.forEach((stop) => {
                gradient.addColorStop(stop.offset, cssColor(stop.color));
            });

            context.fillStyle = gradient;
            context.fillRect(0, 0, renderTexture.width, renderTexture.height);

            // Store the current render-texture binding.
            const renderTarget = renderer.renderTexture.current;
            const sourceFrame = tempSourceFrame.copyFrom(renderer.renderTexture.sourceFrame);
            const destinationFrame = tempDestinationFrame.copyFrom(renderer.renderTexture.destinationFrame);

            const renderSprite = new sprite.Sprite(core.Texture.from(canvas));

            renderer.batch.flush();

            renderer.renderTexture.bind(renderTexture);
            renderSprite.render(renderer);
            
            renderer.batch.flush();
            renderer.renderTexture.bind(renderTarget, sourceFrame, destinationFrame);

            return renderTexture;
        }

        /**
         * Renders a radial-gradient into `renderTexture` that starts at the circle centered at (x0, y0) of radius r0 and
         * ends at the circle centered at (x1, y1) of radius r1.
         * 
         * This method can be called inside a render cycle, and will preserve the renderer state. However, the current implementation
         * causes a batch renderer flush.
         * 
         * @param renderer - The renderer to use for drawing the gradient.
         * @param renderTexture - The texture to render the gradient into.
         * @param options - The gradient parameters.
         * @param options.x0 - The x-coordinate of the starting circle's center.
         * @param options.y0 - The y-coordinate of the starting circle's center.
         * @param options.r0 - The radius of the starting circle.
         * @param options.x1 - The x-coordinate of the ending circle's center.
         * @param options.y1 - The y-coordinate of the ending circle's center.
         * @param options.colorStops - The color stops along the gradient pattern.
         * @todo This implementation is currently using the Canvas API (slow). It will be converted to a WebGL shader.
         * @todo This implementation causes a batch renderer flush. This will be optimized in a future release.
         */
        static createRadialGradient(
            renderer, 
            renderTexture, 
            options








        )
        {
            const { x0, y0, r0, x1, y1, r1, colorStops } = options;

            const canvas = document.createElement('canvas');

            canvas.width = renderTexture.width;
            canvas.height = renderTexture.height;

            const context = canvas.getContext('2d');

            const gradient = context.createRadialGradient(x0, y0, r0, x1, y1, r1);

            colorStops.forEach((stop) => {
                gradient.addColorStop(stop.offset, cssColor(stop.color));
            });

            context.fillStyle = gradient;
            context.fillRect(0, 0, renderTexture.width, renderTexture.height);

            // Store the current render-texture binding.
            const renderTarget = renderer.renderTexture.current;
            const sourceFrame = tempSourceFrame.copyFrom(renderer.renderTexture.sourceFrame);
            const destinationFrame = tempDestinationFrame.copyFrom(renderer.renderTexture.destinationFrame);

            const renderSprite = new sprite.Sprite(core.Texture.from(canvas));

            renderer.batch.flush();

            renderer.renderTexture.bind(renderTexture);
            renderSprite.render(renderer);
            
            renderer.batch.flush();
            renderer.renderTexture.bind(renderTarget, sourceFrame, destinationFrame);

            return renderTexture;
        }
    }

    ;

    exports.GradientFactory = GradientFactory;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
if (typeof _pixi_essentials_gradients !== 'undefined') { Object.assign(this.PIXI, _pixi_essentials_gradients); }
//# sourceMappingURL=gradients.js.map
